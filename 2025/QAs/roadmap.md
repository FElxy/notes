# JavaScript 核心 & 异步编程
1. 事件循环
  * 什么是事件循环
  * setTimeout，promise执行顺序 
  * 事件循环的使用案例
https://github.com/pro-collection/interview-question/issues/142
https://github.com/pro-collection/interview-question/issues/1023
2. 宏任务、微任务
  * 举例哪些是宏任务、微任务
  * 为什么要设计微任务机制？它解决了什么问题？
https://github.com/pro-collection/interview-question/issues/47
https://github.com/pro-collection/interview-question/issues/998
4. 浏览器的事件循环和node的事件循环区别
https://github.com/pro-collection/interview-question/issues/202
5. 变量
  * 变量、变量提升
  变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值 undefined。

6. 调用栈、执行上下文
  * 什么是调用栈
    会出现在一个函数中调用另外一个函数的情况，调用栈就是用来管理函数调用关系的一种数据结构。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。
  * 什么是执行上下文
    执行上下文是 JavaScript 执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。
  * 执行上下文包含了哪些内容
    * 变量环境：存储var变量，函数生命和参数
    * 词法环境：存储let const，管理暂时性死区
    * this绑定
    * 外部引用：指向父级作用域的栈帧，形成作用域链（实现闭包的关键）
    **类型**
    1. 当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。
    2. 当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。
    3. 当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。
7. 作用域
  * 什么是作用域、作用域链，如何形成的
    作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。
    当一段代码使用了一个变量时，JavaScript 引擎首先会在“当前的执行上下文”中查找该变量，如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找。这个查找的链条就称为作用域链。在 JavaScript 执行过程中，其作用域链是由词法作用域决定的。
  * 块级作用域
    执行上下文包含变量环境和词法环境。块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就同时支持了变量提升和块级作用域了。
  * 暂时性死区
    执行函数时才有进行编译，抽象语法树(AST）在进入函数阶段就生成了，并且函数内部作用域是已经明确了，所以进入块级作用域不会有编译过程，只不过通过let或者const声明的变量会在进入块级作用域的时被创建，但是在该变量没有赋值之前，引用该变量JavaScript引擎会抛出错误---这就是“暂时性死区”
  * 什么是闭包
    a. 在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。
    b. 如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。
    c. 如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。
    d. 如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。
  * 如何产生的闭包
  * 闭包有什么应用场景和潜在问题
8. this
  * this的理解
    全局执行上下文中的 this 是指向 window 对象的。严格模式是undefined

  * 改变this
    1. call，bind，apply
    2. 通过对象调用方法设置。使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的。
    3. 构造函数设置。new对象this指向新对象
    4. ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数。

6. 异步方案
  * Promise 有几种状态？状态改变是不可逆的吗？
  * Promise 中 throw new Error() 和 Promise.reject() 有什么区别？
  * 如何实现 Promise.all 和 Promise.race？如果其中一个 Promise 失败，它们的行为分别是什么？
  * async/await 的原理是什么？它和 Generator 有什么关系？
  * 使用 async/await 时，如何优雅地处理错误？

# 浏览器渲染原理 & 性能优化

## 从输入 URL 到页面展示，这中间发生了什么？
1. 用户输入
  * 如果是搜索内容，地址栏使用默认搜索引擎搜索内容
  * 如果是URL，当前页面执行beforeunload事件，如果没有监听或者同意继续后，进入加载状态
2. URL请求过程
  * 浏览器进程通过IPC把URL请求发送到网络进程，网络进程查找本地是否缓存了该资源，如果有缓存直接返回资源；如果没有进入网络请求流程。
  * DNS：进行DNS解析，获取IP地址。如果是HTTPS，则需要建立TLS连接。（建立过程）
    a. 检查缓存：依次查询浏览器缓存、操作系统缓存（hosts文件）、路由器缓存
    b. 递归 / 迭代查询：若缓存未命中，向本地DNS服务器请求，最终通过根域名服务器、顶级域名服务器、权威域名服务器获取IP地址。
    c. 结果缓存：将域名与IP的映射存入缓存，TTL由DNS记录控制
  * TCP：利用IP地址和服务器建立TCP连接，浏览器构建请求信息。服务器接收到请求信息后，生成响应数据。网络进程接收到响应数据后，解析响应头。
    a. 重定向：解析到响应头如果状态码是301或者302，网络进程从location字段读取重定向地址，发起http请求
    b. 响应处理：如果是200，根据Content-Type，如果字节流类型的交给浏览器的下载管理器；如果是HTML，浏览器继续进行导航流程。
  * 三次握手
    a. 第一次握手：客户端发送 SYN 报文. 浏览器（客户端）向服务器发送TCP报文：设置SYN=1，请求建立连接，询问服务器是否准备好建立连接
    b. 第二次握手：服务器回复 SYN-ACK 报文. 服务器收到SYN后回复：设置SYN=1和ACK=1（确认请求），并生成自己的初始序列号seq=y，确认号 ack=x+1，表示已经收到客户端的x
    c. 第三次握手：客户端发送 ACK 报文. 客户端收到SYN-ACK后回复：设置ACK=1,序列号seq=x+1,确认号ack=y+1(表示已经收到服务器的y)，确认服务器的响应，连接正式建立
  为什么需要三次握手？
    * 防止历史连接 -- 避免因网络延迟导致的过期连接请求被误认为新请求
    * 同步初始序列号 -- 双方交换初始序列号（ISN），确保后续数据传输有序
    * 验证双方通信 -- 确保双方收发能力正常
  四次挥手
    * 主动关闭发送FIN（FIN=1,Seq=u），客户端决定不再发送数据，希望关闭到服务器的连接，状态 FIN_WAIT_1,不再发送数据，但是仍可以接收数据
    * 服务端发送ACK（ACK=1,Ack=u+1）确认,服务端进入CLOSE_WAIT状态（半关闭状态），客户端收到ACK后进入FIN_WAIT_2状态
    * 服务端发送FIN+ACK报文（FIN=1,ACK=1,Seq=v,ACK=U+1）,服务端进入：LAST_ACK状态
    * 客户端回复ACK确认（ACK=1,Ack=v+1）,客户端进入TIME_WAIT状态，等待2MSL，服务端收到ACK后立即关闭连接，客户端2MSL超时后关闭连接
3. 准备渲染进程
  * 如果是同一站点，那么复用渲染进程；其他情况，打开新的页面使用新的渲染进程
  * 渲染进程准备好了后，进入到提交稳稳当阶段
4. 提交文档
  * 浏览器进程将网络进程接收到的HTML数据提交给渲染进程
    a. 浏览器进程接收到网络进程的响应头数据之后，想渲染进程发起“提交文档”消息
    b. 渲染进程接收到消息后，和网络进程建立传输数据管道
    c. 文档数据传输完成之后，渲染进程返回“确认提交”的消息给浏览器进程
    d. 浏览器进程收到消息后，更新浏览器界面状态（安全、地址栏URL、历史状态）
  导航阶段完成后，进入到渲染阶段
5. 渲染阶段
  * 渲染路径 构建 -> 布局 -> 绘制 -> 合成
  * 重排（Reflow）和重绘（Repaint）

6. 性能优化
  * 缩短首屏加载时间
  * 性能分析工具、指标
  * 前端缓存策略


# 垃圾回收
在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。
副垃圾回收器，主要负责新生代的垃圾回收。
主垃圾回收器，主要负责老生代的垃圾回收。

垃圾回收器的工作流程
第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。
第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。
第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。

- 把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域
- 新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。
- 在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。
- 完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。

- 经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。

首先是标记过程阶段。遍历调用栈。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。

标记 - 整理（Mark-Compact），这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。