# JavaScript 核心 & 异步编程
1. 事件循环
  * 什么是事件循环
  * setTimeout，promise执行顺序 
  * 事件循环的使用案例
https://github.com/pro-collection/interview-question/issues/142
https://github.com/pro-collection/interview-question/issues/1023

  - 原因：
   由于JavaScript是单线程的语言，只有一个主线程来执行代码。在实际应用中会遇到很多耗时操作，比如：网络请求 (Ajax / fetch)、定时器 (setTimeout, setInterval)、I/O 操作 (读文件、数据库)、DOM 事件 (click, input)。如果所有这些都在主线程 同步执行，页面会卡死。所以 JavaScript 使用 事件循环机制 来调度这些异步任务。

  - 事件循环背后的思想是：
    1. 主线程有一个 调用栈（Call Stack）。
    2. 异步任务完成后，它们的回调会被放入 任务队列（Task Queue / Callback Queue）。
    3. 事件循环 (Event Loop) 负责不断检查调用栈是否为空，如果为空，就从队列取一个任务放进栈中执行。

  - 任务分类
    宏任务（Macro Task），每个宏任务包含一个微任务队列
        - script（整体代码）
        - setTimeout / setInterval
        - setImmediate (Node.js)
        - I/O 操作
        - UI 渲染

    微任务（Micro Task）
        - Promise.then / catch / finally
        - process.nextTick (Node.js)
        - MutationObserver

  - 执行顺序
    执行顺序规则
      - 执行一个 宏任务。
      - 执行期间如果遇到微任务，就把它们放到微任务队列。
      - 当前宏任务执行完毕后，执行当前宏任务中的微任务。
      - 然后再取下一个宏任务执行。
      - 循环往复，这就是 事件循环。

2. 宏任务、微任务
  * 举例哪些是宏任务、微任务
  宏任务（Macro）：
    - setTimeout、setInterval
    - I/O 操作、事件回调
    - setImmediate（Node.js）
    - requestAnimationFrame（浏览器）
    - UI 渲染

    微任务（Micro）：
    - Promise.then/catch/finally
    - queueMicrotask
    - MutationObserver（浏览器）
    - process.nextTick（Node.js，优先级最高）
  * 为什么要设计微任务机制？它解决了什么问题？
  微任务机制解决了在单个宏任务执行后、浏览器渲染前需要执行一些高优先级回调的需求，主要为了确保异步操作的顺序可控和提升响应性能。


https://github.com/pro-collection/interview-question/issues/47
https://github.com/pro-collection/interview-question/issues/998
4. 浏览器的事件循环和node的事件循环区别
  1. 架构设计目标不同
  浏览器：优先响应用户交互，保证页面流畅

  Node.js：高效处理大量 I/O 操作，最大化吞吐量

  2. 阶段划分不同
  浏览器：简单的宏任务/微任务模型

  Node.js：精细的6阶段划分，每个阶段专攻特定任务（timers → pending → idle → poll → check → close）

  3. 特有API
  浏览器特有：requestAnimationFrame、渲染更新

  Node.js特有：process.nextTick、setImmediate

  4. I/O处理方式
  浏览器：主要处理用户事件、网络请求、DOM操作

  Node.js：处理文件、网络、子进程等所有类型I/O
https://github.com/pro-collection/interview-question/issues/202
5. 变量
  * 变量、变量提升
  变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值 undefined。

6. 调用栈、执行上下文
  * 什么是调用栈
    会出现在一个函数中调用另外一个函数的情况，调用栈就是用来管理函数调用关系的一种数据结构。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。
  * 什么是执行上下文
    执行上下文是 JavaScript 执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。
  * 执行上下文包含了哪些内容
    * 变量环境：存储var变量，函数生命和参数
    * 词法环境：存储let const，管理暂时性死区
    * this绑定
    * 外部引用：指向父级作用域的栈帧，形成作用域链（实现闭包的关键）
    **类型**
    1. 当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。
    2. 当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。
    3. 当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。
7. 作用域
  * 什么是作用域、作用域链，如何形成的
    作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。
    当一段代码使用了一个变量时，JavaScript 引擎首先会在“当前的执行上下文”中查找该变量，如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找。这个查找的链条就称为作用域链。在 JavaScript 执行过程中，其作用域链是由词法作用域决定的。
  * 块级作用域
    执行上下文包含变量环境和词法环境。块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就同时支持了变量提升和块级作用域了。
  * 暂时性死区
    执行函数时才有进行编译，抽象语法树(AST）在进入函数阶段就生成了，并且函数内部作用域是已经明确了，所以进入块级作用域不会有编译过程，只不过通过let或者const声明的变量会在进入块级作用域的时被创建，但是在该变量没有赋值之前，引用该变量JavaScript引擎会抛出错误---这就是“暂时性死区”
  * 什么是闭包
    a. 在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。
    b. 如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。
    c. 如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。
    d. 如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。
  * 如何产生的闭包
  * 闭包有什么应用场景和潜在问题
    1. 数据封装：创建私有变量和方法，实现信息隐藏
    2. 模块模式：实现模块化的代码组织
    3. 防抖节流：控制函数执行频率
8. this
  * this的理解
    1. 全局执行上下文中的 this 是指向 window 对象的。严格模式是undefined
    2. 类中的this指向实例
    3. 函数中的this：箭头函数、普通函数
  * 改变this
    1. call，bind，apply
    2. 通过对象调用方法设置。使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的。
    3. 构造函数设置。new对象this指向新对象
    4. ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数。

9. 异步方案
  * Promise 有几种状态？状态改变是不可逆的吗？
  * Promise 中 throw new Error() 和 Promise.reject() 有什么区别？
  * 如何实现 Promise.all 和 Promise.race？如果其中一个 Promise 失败，它们的行为分别是什么？
  * async/await 的原理是什么？它和 Generator 有什么关系？
  * 使用 async/await 时，如何优雅地处理错误？

10. 原型和原型链
原型是 JavaScript 对象继承属性和方法的机制，原型链是通过 __proto__ 链接起来的对象链条，用于实现属性和方法的查找。
  每个对象都有一个原型对象，从中继承属性和方法，
    - 函数的 prototype 属性指向原型对象
    - 对象的 __proto__ 属性指向其原型
  
  原型链：对象通过 __proto__ 连接形成的链条
    - 属性查找时，沿着原型链向上搜索
    - 链的尽头是 Object.prototype，其 __proto__ 为 null

  ```
  // 设置原型（现代方式）
  Object.setPrototypeOf(child, parent);

  // 获取原型（现代方式）
  console.log(Object.getPrototypeOf(child) === parent); // true

  ```
# 浏览器渲染原理 & 性能优化

## 从输入 URL 到页面展示，这中间发生了什么？
1. 用户输入
  * 如果是搜索内容，地址栏使用默认搜索引擎搜索内容
  * 如果是URL，当前页面执行beforeunload事件，如果没有监听或者同意继续后，进入加载状态
2. URL请求过程
  * 浏览器进程通过IPC把URL请求发送到网络进程，网络进程查找本地是否缓存了该资源，如果有缓存直接返回资源；如果没有进入网络请求流程。
  * DNS：进行DNS解析，获取IP地址。如果是HTTPS，则需要建立TLS连接。（建立过程）
    a. 检查缓存：依次查询浏览器缓存、操作系统缓存（hosts文件）、路由器缓存
    b. 递归 / 迭代查询：若缓存未命中，向本地DNS服务器请求，最终通过根域名服务器、顶级域名服务器、权威域名服务器获取IP地址。
    c. 结果缓存：将域名与IP的映射存入缓存，TTL由DNS记录控制
  * TCP：利用IP地址和服务器建立TCP连接，浏览器构建请求信息。服务器接收到请求信息后，生成响应数据。网络进程接收到响应数据后，解析响应头。
    a. 重定向：解析到响应头如果状态码是301或者302，网络进程从location字段读取重定向地址，发起http请求
    b. 响应处理：如果是200，根据Content-Type，如果字节流类型的交给浏览器的下载管理器；如果是HTML，浏览器继续进行导航流程。
  * 三次握手
    a. 第一次握手：客户端发送 SYN 报文. 浏览器（客户端）向服务器发送TCP报文：设置SYN=1，请求建立连接，询问服务器是否准备好建立连接
    b. 第二次握手：服务器回复 SYN-ACK 报文. 服务器收到SYN后回复：设置SYN=1和ACK=1（确认请求），并生成自己的初始序列号seq=y，确认号 ack=x+1，表示已经收到客户端的x
    c. 第三次握手：客户端发送 ACK 报文. 客户端收到SYN-ACK后回复：设置ACK=1,序列号seq=x+1,确认号ack=y+1(表示已经收到服务器的y)，确认服务器的响应，连接正式建立
  为什么需要三次握手？
    * 防止历史连接 -- 避免因网络延迟导致的过期连接请求被误认为新请求
    * 同步初始序列号 -- 双方交换初始序列号（ISN），确保后续数据传输有序
    * 验证双方通信 -- 确保双方收发能力正常
  四次挥手
    * 主动关闭发送FIN（FIN=1,Seq=u），客户端决定不再发送数据，希望关闭到服务器的连接，状态 FIN_WAIT_1,不再发送数据，但是仍可以接收数据
    * 服务端发送ACK（ACK=1,Ack=u+1）确认,服务端进入CLOSE_WAIT状态（半关闭状态），客户端收到ACK后进入FIN_WAIT_2状态
    * 服务端发送FIN+ACK报文（FIN=1,ACK=1,Seq=v,ACK=U+1）,服务端进入：LAST_ACK状态
    * 客户端回复ACK确认（ACK=1,Ack=v+1）,客户端进入TIME_WAIT状态，等待2MSL，服务端收到ACK后立即关闭连接，客户端2MSL超时后关闭连接
3. 准备渲染进程
  * 如果是同一站点，那么复用渲染进程；其他情况，打开新的页面使用新的渲染进程
  * 渲染进程准备好了后，进入到提交稳稳当阶段
4. 提交文档
  * 浏览器进程将网络进程接收到的HTML数据提交给渲染进程

    1. 浏览器进程接收到网络进程的响应头数据之后，想渲染进程发起“提交文档”消息
    2. 渲染进程接收到消息后，和网络进程建立传输数据管道
    3. 文档数据传输完成之后，渲染进程返回“确认提交”的消息给浏览器进程
    4. 浏览器进程收到消息后，更新浏览器界面状态（安全、地址栏URL、历史状态）
  导航阶段完成后，进入到渲染阶段
5. 渲染阶段: 渲染路径 构建 -> 样式计算 -> 布局 -> 绘制 -> 合成
   1. 构建 DOM 树。需要将 HTML 转换为浏览器能够理解的结构——DOM 树。
   2. 样式计算。计算出 DOM 节点中每个元素的具体样式
      - 把 CSS 转换为浏览器能够理解的结构
     CSS 样式来源主要有三种：1.通过 link 引用的外部 CSS 文件; 2.通过 link 引用的外部 CSS 文件;3.元素的 style 属性内嵌的 CSS。当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。
      - 转换样式表中的属性值，使其标准化(2em、blue、bold)
      - 计算出 DOM 树中每个节点的具体样式。CSS 的继承规则和层叠规则.
   3. 布局阶段
      
      布局就是计算出 DOM 树中可见元素的几何位置。
      - 创建布局树：构建一棵只包含可见元素布局树。（不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。）
      - 布局计算
      在JavaScript中访问了某个元素的样式，那么这时候就需要等待这个样式被下载完成才能继续往下执行，所以在这种情况下，CSS也会阻塞DOM的解析。
    4. 分层

       渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）
      （复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等）

      * 第一点，拥有层叠上下文属性的元素会被提升为单独的一层。（明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。）

      * 第二点，需要剪裁（clip）的地方也会被创建为图层。（文字超出、滚动条）

    5. 图层绘制
      
       把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表
    
    6. 栅格化（raster）操作
       合成线程会将图层划分为图块（tile），然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。

    7. 合成
       一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

    > 一个完整的渲染流程大致可总结为如下：
    > 1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
    > 2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
    > 3. 创建布局树，并计算元素的布局信息。
    > 4. 对布局树进行分层，并生成分层树。
    > 5. 为每个图层生成绘制列表，并将其提交到合成线程。
    > 6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
    > 7. 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

    重排  
    通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。

    重绘  
    如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。

    合成  
    使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。

6. 性能优化
  * 缩短首屏加载时间
  * 性能分析工具、指标
  * 前端缓存策略

  1. **FCP（First Contentful Paint） - 首次内容绘制**
    - **含义**：FCP是指浏览器首次绘制来自DOM的任何内容（如文本、图像、非白色的`<canvas>`或SVG）的时间点。这是用户体验的一个重要指标，因为它标志着页面开始有实际内容显示给用户，而不仅仅是空白的屏幕。
    - **重要性**：对于用户来说，快速的FCP可以让他们感觉到页面正在加载，减少等待的焦虑。一般来说，良好的FCP时间应该在1.8秒以内。

  2. **LCP（Largest Contentful Paint） - 最大内容绘制**
    - **含义**：LCP是指在视口（viewport）内可见的最大图像或文本块的绘制时间。这个指标重点关注页面主要内容的加载情况，因为主要内容通常是用户最关注的部分。例如，对于一个新闻页面，文章中的主图或者标题部分可能是LCP元素；对于一个电商页面，产品图片和主要的产品描述可能是LCP元素。
    - **重要性**：LCP能够更好地反映用户感知到的页面加载速度。一个好的LCP时间有助于用户快速获取页面最重要的信息。谷歌建议LCP应在2.5秒内完成，以提供良好的用户体验。

  3. **TTFB（Time to First Byte） - 首字节时间**
    - **含义**：TTFB是指浏览器从开始请求页面到收到第一个字节的时间。这个时间包括了网络传输时间、服务器处理时间等多个因素。它是衡量服务器响应速度和网络性能的一个重要指标。
    - **重要性**：较短的TTFB意味着服务器能够快速响应浏览器的请求，为后续的页面加载提供了一个良好的开端。如果TTFB过长，可能是服务器性能问题或者网络连接不佳导致的，会影响整个页面的加载速度。

  4. **FID（First Input Delay） - 首次输入延迟**
    - **含义**：FID衡量的是用户首次与页面交互（如点击、按键等）到浏览器开始响应这个交互的时间间隔。它反映了页面在交互事件处理上的及时性。
    - **重要性**：对于提供良好的用户体验来说，快速响应用户的首次输入至关重要。如果FID过高，用户可能会感觉页面卡顿或者无响应，尤其是在需要快速交互的场景，如游戏、表单填写等。谷歌建议FID应控制在100毫秒以内。

  5. **TTI（Time to Interactive） - 可交互时间**
    - **含义**：TTI是指页面从开始加载到变得完全可交互所花费的时间。完全可交互意味着用户可以可靠地与页面进行各种交互操作，如点击链接、输入文本等，并且页面能够及时响应这些操作。这个指标综合考虑了JavaScript加载、解析和执行，以及页面布局的稳定等多个因素。
    - **重要性**：TTI直接关系到用户能够有效使用页面的时间点。一个较短的TTI可以让用户更快地开始使用页面的功能，提高用户满意度和工作效率。

  6. **CLS（Cumulative Layout Shift） - 累积布局偏移**
    - **含义**：CLS用于衡量页面在加载过程中发生的视觉稳定性。它计算的是页面布局在加载和交互过程中的意外移动情况。例如，当一个元素最初在屏幕上的一个位置，但是由于后续资源加载导致布局改变，该元素位置发生了偏移，这就会产生CLS。
    - **重要性**：良好的视觉稳定性是优质用户体验的关键。如果CLS过高，用户可能会在阅读或操作过程中感到困惑，甚至可能导致误操作。谷歌建议将CLS控制在0.1或以下。

  7. **TBT（Total Blocking Time） - 总阻塞时间**
    - **含义**：TBT是指在FCP和TTI之间，主线程被阻塞（无法响应用户输入）的总时间。这主要是由于长时间的JavaScript执行或者其他主线程任务导致的。
    - **重要性**：较低的TBT意味着页面能够更快地变得可交互，减少用户等待的时间。它有助于评估页面在加载过程中对用户交互的阻塞情况，从而优化性能，提高用户体验。

# 垃圾回收
在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。
副垃圾回收器，主要负责新生代的垃圾回收。
主垃圾回收器，主要负责老生代的垃圾回收。

垃圾回收器的工作流程
第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。
第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。
第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。

- 把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域
- 新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。
- 在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。
- 完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。

- 经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。

首先是标记过程阶段。遍历调用栈。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。

标记 - 整理（Mark-Compact），这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

# 网络

| OSI 七层模型 | TCP/IP 四层模型 | 典型协议/标准                         |
| -------- | ----------- | ------------------------------- |
| 应用层      | 应用层         | HTTP, FTP, DNS, SMTP, SSH, DHCP |
| 表示层      | 应用层         | TLS/SSL（加密、压缩、编码）               |
| 会话层      | 应用层         | RPC, NetBIOS                    |
| 传输层      | 传输层         | TCP, UDP                        |
| 网络层      | 网络层         | IP, ICMP, ARP, IGMP             |
| 数据链路层    | 网络接口层       | Ethernet, PPP, 802.11 (Wi-Fi)   |
| 物理层      | 网络接口层       | 光纤、电缆、无线电波、硬件接口                 |

http
三次握手

http2.0
https
cors

TCP/IP 协议通过确认和重传、滑动窗口、序列号以及超时重传时间等机制，保证了数据包传输的有序可靠性。

DNS（Domain Name System，域名系统）是因特网上用于将主机名转换为 IP 地址的协议。

在使用 DNS 协议进行主机名解析时，系统首先查询本地 DNS 缓存。如果缓存中不存在结果，系统将向本地 DNS 服务器发出请求，并逐级向上查找，直到找到权威 DNS 服务器并获得解析结果。

TCP队头阻塞
# 框架

# 工程化

# 跨端

# AI


https://github.com/danielmapar/NodeJSAdvancedConcepts