
## 🧩 一、JavaScript与TypeScript

### ✅ 基础

#### 1. JS 的执行机制是怎样的？事件循环中有哪些队列？
JavaScript 是单线程的，采用**事件循环（Event Loop）**机制来处理同步和异步任务。

执行时会先执行主线程上的同步任务，同步任务执行完后，事件循环会不断从任务队列中取出异步任务的回调执行。

事件循环中主要有两个队列：
1️⃣ 宏任务队列（Macro Task Queue）：包括 setTimeout、setInterval、setImmediate、I/O、script(整体代码) 等。
2️⃣ 微任务队列（Micro Task Queue）：包括 Promise.then、MutationObserver、queueMicrotask 等。

每一轮事件循环中，JS 会先执行一个宏任务，然后清空所有微任务，再进入下一轮循环。

#### 事件循环
JavaScript 是单线程的。事件循环是用来协调同步任务和异步任务的执行机制。
每次循环会先执行一个宏任务（例如 script、setTimeout），执行过程中产生的微任务（如 Promise.then）会在当前宏任务结束后立即执行。
当所有微任务清空后，浏览器可能进行渲染，然后进入下一轮循环。
这保证了 JS 在单线程下依然可以高效地处理异步逻辑。

Node.js 也有事件循环，但分为多个阶段（timers、poll、check等），微任务会在每个阶段后执行。
浏览器中则是 宏任务 → 微任务 → 渲染 → 下一轮。


#### 浏览器的事件循环和node的事件循环区别

####  `var`、`let`、`const` 的区别是什么？为什么存在暂时性死区？
var 是函数作用域，会变量提升，声明前访问值为 undefined；
let 和 const 是块级作用域，也会被提升，但在声明前处于“暂时性死区”，访问会报错；
const 还要求声明时必须赋初值，且不能重新赋值。

存在暂时性死区是为了避免变量提升导致的逻辑混乱，让变量在声明之前不能被访问，语义更清晰。

#### 调用栈、执行上下文

#### 作用域、作用域链

#### 3. 解释闭包与作用域链。闭包可能导致哪些性能或内存问题？
作用域链是指当访问一个变量时，JS 会从当前作用域开始，一层层向外查找父级作用域，直到全局作用域为止。

闭包是指一个函数可以访问其外部函数作用域中的变量，即使外部函数已经执行结束。

闭包的本质是函数+其引用的外部变量环境。

性能/内存问题：
闭包会使外层函数的变量无法被垃圾回收，如果大量创建或长期持有闭包，可能造成内存泄漏。

优化建议：
在不再需要时手动释放引用，例如将闭包变量设为 null 或让引用脱离作用域。

#### 4. `this` 在不同调用场景下如何绑定？箭头函数为什么不能修改 `this`？
  * this的理解
    1. 全局执行上下文中的 this 是指向 window 对象的。严格模式是undefined
    2. 类中的this指向实例
    3. 函数中的this：箭头函数、普通函数
  * 改变this
    1. call，bind，apply
    2. 通过对象调用方法设置。使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的。
    3. 构造函数设置。new对象this指向新对象
    4. ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数。

#### 5. 原型与原型链的工作原理是什么？
在 JavaScript 中，每个对象都有一个内部属性 [[Prototype]]（可通过 __proto__ 访问），它指向另一个对象，称为原型（prototype）。

对于函数来说，函数本身也有一个 prototype 属性，用来给通过 new 创建的实例对象设置它们的原型。

当我们访问一个对象的属性时：
1️⃣ JS 会先在对象自身查找；
2️⃣ 如果没有找到，就沿着 [[Prototype]] 向上查找；
3️⃣ 一直查到 Object.prototype，若仍未找到则返回 undefined。

这条从对象自身一路向上的查找链就叫做原型链（Prototype Chain）。



### ⚙️ 进阶

#### 1. Promise 是如何实现的？`then` 链式调用是怎么保证顺序的？
Promise 是一种异步编程模型，本质是一个状态机，有三种状态：pending、fulfilled、rejected，状态一旦变化就不可逆。

内部实现是通过在构造函数中接收一个执行器函数 (resolve, reject)，执行时会：
1️⃣ 立即执行同步逻辑；
2️⃣ 把异步回调存入任务队列；
3️⃣ 调用 resolve 或 reject 后触发状态变化，并依次执行回调。

then 的链式调用依靠返回新的 Promise 实例实现：

每次调用 .then() 都会生成一个新的 Promise；

上一个 Promise 的结果会传递给下一个；

如果回调函数返回一个值，会用 resolve 包装；

如果返回的是 Promise，则会等待它的状态（即“扁平化”机制）。

顺序保证机制：
then 中注册的回调会被放入 微任务队列（Microtask Queue），
在当前宏任务执行完后按注册顺序执行，
所以 .then().then().then() 是严格按顺序依次执行的。

#### 2. async/await 底层是如何实现的？与生成器函数（generator）有什么关系？
async/await 是对 Promise 和 Generator 的语法糖，本质上是通过自动执行 Generator 来实现同步风格的异步代码。

当你声明一个 async 函数时，它会默认返回一个 Promise；
函数内部的 await 会暂停执行，等待右侧表达式的 Promise resolve，然后恢复执行。

底层原理是：
1️⃣ async 函数在执行时，会像生成器一样被“分段执行”；
2️⃣ 每次遇到 await，JS 引擎会将后续代码封装成 Promise 回调（即微任务）；
3️⃣ 当 Promise resolve 后，恢复函数执行；
4️⃣ 如果抛出异常，则相当于 Promise reject。

#### 3. 解释事件委托机制，它的性能优势体现在哪？

事件委托是指不直接给每个子元素绑定事件，而是把事件绑定到父元素上，通过事件冒泡来统一处理子元素的事件。

原理：
1️⃣ 当事件发生在子元素时，会向上传播到父元素（冒泡）；
2️⃣ 父元素在事件处理函数里，通过 event.target 判断实际触发的子元素；
3️⃣ 根据条件执行对应逻辑。

性能优势：
1️⃣ 减少内存占用：只绑定一个事件处理函数，而不是每个子元素都绑定。
2️⃣ 动态元素也可生效：新增的子元素无需再绑定事件，父元素的事件处理器自动生效。
3️⃣ 管理更方便：统一处理逻辑，减少重复代码。

#### 4. Symbol、Proxy、Reflect 分别的应用场景是什么？

#### 5. 深拷贝实现有哪些方式？其中的陷阱是什么？

### 🧠 深入

#### 1. JS 引擎如何进行内存管理与垃圾回收？

#### 2. 解释一次 JS 的“编译执行”全过程，从解析到优化。
1️⃣ 解析阶段（Parsing）

词法分析（Lexical Analysis）：把源代码拆分成Token，例如关键字、标识符、运算符。

语法分析（Syntax Analysis）：将 Token 生成 AST（抽象语法树），表示代码结构。

作用域分析（Scope Analysis）：构建作用域链和变量环境，确定变量提升、var/let/const 等信息。

2️⃣ 编译阶段（Compilation / Bytecode Generation）

现代 JS 引擎（如 V8）采用 即时编译（JIT）：

生成字节码（Bytecode），供解释器（Ignition）执行。

进行类型推断，记录变量类型信息，为后续优化做准备。

3️⃣ 执行阶段（Execution / Interpretation）

解释器逐条执行字节码：

执行函数、表达式、控制流。

维护执行上下文栈（Call Stack）。

管理作用域、闭包和 this 绑定。

异步任务通过 事件循环调度，微任务和宏任务队列保证顺序执行。

4️⃣ 优化阶段（Optimization / Deoptimization）

引擎会监控函数运行的热度（Hot Path），对频繁执行的函数进行优化编译（Optimized Machine Code）。

V8 流程：

Ignition（解释器）执行字节码 → 采集类型信息

TurboFan（优化编译器）生成优化机器码

如果类型不符合预测，会**去优化化（deopt）**回到字节码执行。

5️⃣ 垃圾回收

在执行阶段，JS 引擎通过 可达性分析 + 标记清除回收不再使用的对象内存。


---

## 🧱 二、浏览器与性能优化

### ✅ 基础

#### 1. 从输入 URL 到页面渲染完成，发生了什么？
输入URL → DNS解析 → 建立TCP → 建立TLS → 发送HTTP请求 → 服务器响应 → 浏览器解析渲染 → 页面展示

2. 浏览器的渲染流程有哪些关键阶段？（解析、构建DOM、CSSOM、合成层等）
渲染路径 构建 -> 样式计算 -> 布局 -> 绘制 -> 合成

3. 什么是重排（Reflow）与重绘（Repaint）？
重排（Reflow/Layout） → 需要重新计算布局 → 通常会触发重绘
重绘（Repaint/Paint） → 仅像素渲染，不影响布局

优化原则：

避免频繁操作 DOM，批量修改

使用 class 切换而非逐个样式修改

使用 transform、opacity 做动画，避免触发 Reflow

4. 如何减少白屏时间？

### ⚙️ 进阶

1. 浏览器缓存机制（强缓存 / 协商缓存）是如何工作的？
2. 同源策略是什么？如何安全地实现跨域通信？
3. Chrome 的多进程架构设计有哪些优点？
4. 如何分析与优化首屏性能？具体指标有哪些（如 LCP、FID、CLS）？
5. 如何利用 Web Worker 提升性能？

### 🧠 深入

1. 解释浏览器的合成机制（Compositing），哪些CSS属性会触发新层？
2. 现代浏览器的渲染管线中，如何实现 GPU 加速？
3. Service Worker 在性能与离线缓存中的作用？
4. 如何调优一段耗时的渲染任务，避免阻塞主线程？
5. 讲讲你做过的性能优化案例，效果如何？数据如何量化？

---

## ⚛️ 三、框架与工程化（React / Vue / Flutter / RN）

### ✅ 基础

1. React 的虚拟 DOM 是什么？为什么要用它？
2. Vue 的响应式原理（2.x vs 3.x）区别？
3. React Hooks 的使用规则和底层原理？
4. 组件通信有哪些方式？
5. 生命周期钩子分别在什么时候执行？

### ⚙️ 进阶


#### fiber
1. 具体做了什么事情
2. 具体场景的执行优先级
3. 怎么进行任务终止的



#### 什么是fiber
Fiber 是 React 16 引入的底层架构，用于 **增量渲染和调度 UI 更新**。

* 它将渲染任务拆成小块，可中断、恢复，避免复杂更新阻塞主线程。
* 支持优先级调度，高优先级任务（如用户输入）先执行，低优先级任务延后。
* 每个组件对应一个 Fiber 节点，记录状态、子节点、兄弟节点等，形成链表树结构，用于高效更新。


#### React Fiber 架构解决了什么问题？
React Fiber 架构主要解决了 **React 之前同步渲染带来的性能和响应性问题**。具体来说：

1. **阻塞主线程问题**

   * 以前 React 更新是同步的，遇到大规模或复杂组件树更新时，会导致页面卡顿，用户交互被阻塞。
   * Fiber 将渲染拆分成小任务，可以暂停和恢复，避免长时间占用主线程。

2. **缺乏优先级调度**

   * 以前所有更新一视同仁，无法区分重要性。
   * Fiber 支持不同优先级的更新，高优先级任务（如输入、动画）先执行，低优先级任务（如后台渲染）可以延后。

3. **无法增量渲染**

   * 旧版 React 需要一次性完成整个更新，导致大组件树更新时性能下降。
   * Fiber 支持增量渲染（分时间片完成），保证 UI 响应流畅。

一句话总结：

> Fiber 架构让 React 的界面更新 **可中断、可分片、按优先级调度**，解决了大规模更新卡顿和响应慢的问题。


#### 2. Vue 的 Diff 算法与 React 的有什么不同？
1️⃣ React 的 Diff 算法（React Fiber）

核心策略：

同层比对：只在同一层级的节点进行 Diff

不同类型节点 → 整棵子树重新渲染

同类型节点 → 复用 DOM，只更新属性

优化手段：

key 用于标识列表元素，帮助最小化移动操作

Fiber 架构允许将渲染工作拆分成小任务（Incremental Rendering）

算法复杂度：O(n)，按同层比较

2️⃣ Vue 的 Diff 算法（Vue 2.x/3.x）

核心策略：

同层比较 + 双端指针优化（针对列表）

当节点数量多时，使用 前后指针同时扫描，减少移动和重排

支持 key 优化节点复用，未使用 key 时采用就地复用（patch in place）

列表 Diff 优化：

Vue 会先尝试最长递增子序列（LIS）算法来减少真实 DOM 移动次数

对于静态节点，Vue 会直接跳过对比，提高性能

#### 3. 在复杂应用中，状态管理如何设计？Redux / MobX / Pinia / Recoil 对比？
Redux：严格不可变状态、适合大型复杂应用；
MobX：响应式自动追踪，适合中大型应用；
Pinia：Vue 官方推荐，响应式、易用；
Zustand：React hook 风格轻量状态管理，灵活简洁。

#### 4. 如何优化 React 组件的重渲染？
#### 5. SSR（服务端渲染）与 CSR、Hydration 的区别与实现思路？

### 🧠 深入

1. 如果要实现一个简化版的 React（或 Vue），你会如何设计？
2. 如何在 React 中实现一个可中断的渲染任务调度器？
3. 讲讲你在大型项目中做过的架构重构。
4. 你如何设计组件库？有哪些规范与自动化工具链？
5. 在 Flutter / React Native 跨端开发中，你遇到过的性能瓶颈及优化方案？

---

## 🧮 四、网络与安全

### ✅ 基础

1. TCP 三次握手和四次挥手过程？
2. HTTPS 的加密过程？
3. HTTP/1.1、HTTP/2、HTTP/3 的区别？
4. 常见的HTTP状态码有哪些？
5. Cookie、Session、Token、JWT 的区别？
#### https
1. CA证书是从哪里获取的
2. 怎么保证CA的有效性


建立流程TLS1.2
```
客户端（浏览器）                      服务器
     | -------- ClientHello --------> |   ① 提出加密支持
     | <-------- ServerHello -------- |   ② 确定加密方案
     | <---- Certificate + Key -----> |   ③ 服务器证书、公钥
     | -------- ClientKeyExchange --> |   ④ 客户端生成密钥
     | -------- ChangeCipherSpec ---->|   ⑤ 通知切换到加密模式
     | <------- ChangeCipherSpec -----|   ⑥ 服务端也切换
     | <------- Finished -------------|   ⑦ 握手完成
     | -------- Finished ------------>|   ⑧ 双方确认
（之后使用对称密钥加密传输 HTTP 数据）

```
👉 TLS 1.3 把 ServerHello 后的所有内容（包括证书）都放在加密通道里传输，安全性更强。
👉 同时支持 0-RTT 模式：如果是重连，可直接复用上次的会话密钥，几乎无延迟。


#### websocket
1. 数据传输方式
2. 状态码
3. 怎么实现重连

### ⚙️ 进阶

1. 什么是CORS？如何安全地解决跨域？
2. XSS 和 CSRF 的攻击原理与防御方案？
3. 如何在前端保障数据安全？
4. 前端如何实现断点续传、秒传、并发上传？
5. WebSocket 和 SSE 的区别与使用场景？

### 🧠 深入

1. 你如何优化大文件上传过程中的传输性能？
2. 前端如何处理复杂权限控制？
3. 如何在前端层面实现加密存储与防篡改机制？
4. 你对 QUIC 协议的理解？
5. WebAssembly 在前端性能优化中的应用场景？

---

## 🧰 五、构建与工程化

### ✅ 基础

1. Webpack、Vite 的构建原理？
2. Tree-shaking 的原理？
3. Babel 的作用是什么？preset-env 是怎么工作的？
4. 如何处理 polyfill？
5. package-lock.json 的作用？

### ⚙️ 进阶

1. Rollup、ESBuild、Vite 的区别？
2. 如何提升构建速度？
3. CI/CD 在前端工程化中如何设计？
4. Monorepo 与 Multirepo 的取舍？
5. 如何搭建自己的组件库或npm包？

### 🧠 深入

1. 如何实现一个简化版的打包器？
2. 如何在大规模项目中优化依赖管理与构建速度？
3. 讲讲你设计或维护过的前端工程体系。
4. 如何做灰度发布与版本回滚？
5. 代码质量保障体系：Lint、Prettier、Test、Review 如何配合？

---

## 🧭 六、业务与架构设计

1. 当项目体量变大后，你如何设计前端架构？
2. 微前端的优缺点与使用场景？
3. 你如何在项目中做性能监控与异常监控？
4. 如何定位线上白屏或接口异常问题？
5. 如何设计一个高扩展性、低耦合的前端系统？

---

## 🔍 七、开放问题（软实力与思维）

1. 你如何衡量一次前端优化是否有效？
2. 描述一次你主导的技术决策过程。
3. 当设计方案和后端或产品冲突时，你会怎么处理？
4. 如果给你一个新团队，从零开始搭建项目，你会如何规划？
5. 你最近学习的技术是什么？为什么学它？

---






### 函数柯里化
柯里化（Currying）：
是把接受多个参数的函数，转换成一系列只接收一个参数的函数的过程。



## 断点续传
1. 文件怎么分片
2. 具体怎么传
3. indexDB存储上限
IndexedDB 的存储上限不是固定值，而是动态配额。
一般来说：

桌面 Chrome 等 Chromium 浏览器：单源最多可用几 GB（约占磁盘空间 1%～10%）；

Safari / iOS 环境更严格（默认约 50MB～500MB）；

超出时会触发 QuotaExceededError；

可用 navigator.storage.estimate() 查询配额，并通过 navigator.storage.persist() 申请持久存储。


### 虚拟滚动列表和虚拟dom有什么相似与区别
### 文件导出重难点是什么
### 写一个多线程执行任务的最短时间，比如有一个tasks数组，记录了每个任务的执行时间，有一个数n是当前有n个执行器，分别可以执行tasks里面的人物，怎么分配执行时间最短


---

https://www.yuque.com/yuqueyonghua2m9wj/web_food/ftkiwu