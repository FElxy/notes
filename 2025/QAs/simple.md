## 事件循环

JavaScript 是单线程的。事件循环是用来协调同步任务和异步任务的执行机制。
每次循环会先执行一个宏任务（例如 script、setTimeout），执行过程中产生的微任务（如 Promise.then）会在当前宏任务结束后立即执行。
当所有微任务清空后，浏览器可能进行渲染，然后进入下一轮循环。
这保证了 JS 在单线程下依然可以高效地处理异步逻辑。

Node.js 也有事件循环，但分为多个阶段（timers、poll、check等），微任务会在每个阶段后执行。
浏览器中则是 宏任务 → 微任务 → 渲染 → 下一轮。

### var、let、const 的区别是什么？为什么存在暂时性死区？
var 是函数作用域，会变量提升，声明前访问值为 undefined；
let 和 const 是块级作用域，也会被提升，但在声明前处于“暂时性死区”，访问会报错；
const 还要求声明时必须赋初值，且不能重新赋值。


### 函数柯里化
柯里化（Currying）：
是把接受多个参数的函数，转换成一系列只接收一个参数的函数的过程。
## websocket
1. 数据传输方式
2. 状态码
3. 怎么实现重连

## https
1. CA证书是从哪里获取的
2. 怎么保证CA的有效性

建立流程TLS1.2
```
客户端（浏览器）                      服务器
     | -------- ClientHello --------> |   ① 提出加密支持
     | <-------- ServerHello -------- |   ② 确定加密方案
     | <---- Certificate + Key -----> |   ③ 服务器证书、公钥
     | -------- ClientKeyExchange --> |   ④ 客户端生成密钥
     | -------- ChangeCipherSpec ---->|   ⑤ 通知切换到加密模式
     | <------- ChangeCipherSpec -----|   ⑥ 服务端也切换
     | <------- Finished -------------|   ⑦ 握手完成
     | -------- Finished ------------>|   ⑧ 双方确认
（之后使用对称密钥加密传输 HTTP 数据）

```
👉 TLS 1.3 把 ServerHello 后的所有内容（包括证书）都放在加密通道里传输，安全性更强。
👉 同时支持 0-RTT 模式：如果是重连，可直接复用上次的会话密钥，几乎无延迟。



## fiber
1. 具体做了什么事情
2. 具体场景的执行优先级
3. 怎么进行任务终止的


## 断点续传
1. 文件怎么分片
2. 具体怎么传
3. indexDB存储上限
IndexedDB 的存储上限不是固定值，而是动态配额。
一般来说：

桌面 Chrome 等 Chromium 浏览器：单源最多可用几 GB（约占磁盘空间 1%～10%）；

Safari / iOS 环境更严格（默认约 50MB～500MB）；

超出时会触发 QuotaExceededError；

可用 navigator.storage.estimate() 查询配额，并通过 navigator.storage.persist() 申请持久存储。


### 虚拟滚动列表和虚拟dom有什么相似与区别
### 文件导出重难点是什么
### 写一个多线程执行任务的最短时间，比如有一个tasks数组，记录了每个任务的执行时间，有一个数n是当前有n个执行器，分别可以执行tasks里面的人物，怎么分配执行时间最短


---

## 🧩 一、JavaScript与TypeScript

### ✅ 基础

1. JS 的执行机制是怎样的？事件循环中有哪些队列？
JavaScript 是单线程的，采用**事件循环（Event Loop）**机制来处理同步和异步任务。

执行时会先执行主线程上的同步任务，同步任务执行完后，事件循环会不断从任务队列中取出异步任务的回调执行。

事件循环中主要有两个队列：
1️⃣ 宏任务队列（Macro Task Queue）：包括 setTimeout、setInterval、setImmediate、I/O、script(整体代码) 等。
2️⃣ 微任务队列（Micro Task Queue）：包括 Promise.then、MutationObserver、queueMicrotask 等。

每一轮事件循环中，JS 会先执行一个宏任务，然后清空所有微任务，再进入下一轮循环。

2. `var`、`let`、`const` 的区别是什么？为什么存在暂时性死区？
var 是函数作用域，会变量提升，声明前访问值为 undefined；
let 和 const 是块级作用域，也会被提升，但在声明前处于“暂时性死区”，访问会报错；
const 还要求声明时必须赋初值，且不能重新赋值。

存在暂时性死区是为了避免变量提升导致的逻辑混乱，让变量在声明之前不能被访问，语义更清晰。

3. 解释闭包与作用域链。闭包可能导致哪些性能或内存问题？
作用域链是指当访问一个变量时，JS 会从当前作用域开始，一层层向外查找父级作用域，直到全局作用域为止。

闭包是指一个函数可以访问其外部函数作用域中的变量，即使外部函数已经执行结束。

闭包的本质是函数+其引用的外部变量环境。

性能/内存问题：
闭包会使外层函数的变量无法被垃圾回收，如果大量创建或长期持有闭包，可能造成内存泄漏。

优化建议：
在不再需要时手动释放引用，例如将闭包变量设为 null 或让引用脱离作用域。

4. `this` 在不同调用场景下如何绑定？箭头函数为什么不能修改 `this`？

5. 原型与原型链的工作原理是什么？
在 JavaScript 中，每个对象都有一个内部属性 [[Prototype]]（可通过 __proto__ 访问），它指向另一个对象，称为原型（prototype）。

对于函数来说，函数本身也有一个 prototype 属性，用来给通过 new 创建的实例对象设置它们的原型。

当我们访问一个对象的属性时：
1️⃣ JS 会先在对象自身查找；
2️⃣ 如果没有找到，就沿着 [[Prototype]] 向上查找；
3️⃣ 一直查到 Object.prototype，若仍未找到则返回 undefined。

这条从对象自身一路向上的查找链就叫做原型链（Prototype Chain）。


### ⚙️ 进阶

1. Promise 是如何实现的？`then` 链式调用是怎么保证顺序的？
Promise 是一种异步编程模型，本质是一个状态机，有三种状态：pending、fulfilled、rejected，状态一旦变化就不可逆。

内部实现是通过在构造函数中接收一个执行器函数 (resolve, reject)，执行时会：
1️⃣ 立即执行同步逻辑；
2️⃣ 把异步回调存入任务队列；
3️⃣ 调用 resolve 或 reject 后触发状态变化，并依次执行回调。

then 的链式调用依靠返回新的 Promise 实例实现：

每次调用 .then() 都会生成一个新的 Promise；

上一个 Promise 的结果会传递给下一个；

如果回调函数返回一个值，会用 resolve 包装；

如果返回的是 Promise，则会等待它的状态（即“扁平化”机制）。

顺序保证机制：
then 中注册的回调会被放入 微任务队列（Microtask Queue），
在当前宏任务执行完后按注册顺序执行，
所以 .then().then().then() 是严格按顺序依次执行的。

2. async/await 底层是如何实现的？与生成器函数（generator）有什么关系？
async/await 是对 Promise 和 Generator 的语法糖，本质上是通过自动执行 Generator 来实现同步风格的异步代码。

当你声明一个 async 函数时，它会默认返回一个 Promise；
函数内部的 await 会暂停执行，等待右侧表达式的 Promise resolve，然后恢复执行。

底层原理是：
1️⃣ async 函数在执行时，会像生成器一样被“分段执行”；
2️⃣ 每次遇到 await，JS 引擎会将后续代码封装成 Promise 回调（即微任务）；
3️⃣ 当 Promise resolve 后，恢复函数执行；
4️⃣ 如果抛出异常，则相当于 Promise reject。

3. 解释事件委托机制，它的性能优势体现在哪？

事件委托是指不直接给每个子元素绑定事件，而是把事件绑定到父元素上，通过事件冒泡来统一处理子元素的事件。

原理：
1️⃣ 当事件发生在子元素时，会向上传播到父元素（冒泡）；
2️⃣ 父元素在事件处理函数里，通过 event.target 判断实际触发的子元素；
3️⃣ 根据条件执行对应逻辑。

性能优势：
1️⃣ 减少内存占用：只绑定一个事件处理函数，而不是每个子元素都绑定。
2️⃣ 动态元素也可生效：新增的子元素无需再绑定事件，父元素的事件处理器自动生效。
3️⃣ 管理更方便：统一处理逻辑，减少重复代码。

4. Symbol、Proxy、Reflect 分别的应用场景是什么？

5. 深拷贝实现有哪些方式？其中的陷阱是什么？

### 🧠 深入

1. JS 引擎如何进行内存管理与垃圾回收？

2. 解释一次 JS 的“编译执行”全过程，从解析到优化。
3. TypeScript 的类型系统是如何实现的？与结构化类型系统（structural typing）的关系？
4. 如何在大型项目中设计类型系统，平衡灵活性与安全性？
5. 如何在 JS 层面实现一个简单的响应式系统（类似 Vue2）？

---

## 🧱 二、浏览器与性能优化

### ✅ 基础

1. 从输入 URL 到页面渲染完成，发生了什么？
2. 浏览器的渲染流程有哪些关键阶段？（解析、构建DOM、CSSOM、合成层等）
3. 什么是重排（Reflow）与重绘（Repaint）？
4. 如何减少白屏时间？

### ⚙️ 进阶

1. 浏览器缓存机制（强缓存 / 协商缓存）是如何工作的？
2. 同源策略是什么？如何安全地实现跨域通信？
3. Chrome 的多进程架构设计有哪些优点？
4. 如何分析与优化首屏性能？具体指标有哪些（如 LCP、FID、CLS）？
5. 如何利用 Web Worker 提升性能？

### 🧠 深入

1. 解释浏览器的合成机制（Compositing），哪些CSS属性会触发新层？
2. 现代浏览器的渲染管线中，如何实现 GPU 加速？
3. Service Worker 在性能与离线缓存中的作用？
4. 如何调优一段耗时的渲染任务，避免阻塞主线程？
5. 讲讲你做过的性能优化案例，效果如何？数据如何量化？

---

## ⚛️ 三、框架与工程化（React / Vue / Flutter / RN）

### ✅ 基础

1. React 的虚拟 DOM 是什么？为什么要用它？
2. Vue 的响应式原理（2.x vs 3.x）区别？
3. React Hooks 的使用规则和底层原理？
4. 组件通信有哪些方式？
5. 生命周期钩子分别在什么时候执行？

### ⚙️ 进阶

1. React Fiber 架构解决了什么问题？
2. Vue 的 Diff 算法与 React 的有什么不同？
3. 在复杂应用中，状态管理如何设计？Redux / MobX / Pinia / Recoil 对比？
4. 如何优化 React 组件的重渲染？
5. SSR（服务端渲染）与 CSR、Hydration 的区别与实现思路？

### 🧠 深入

1. 如果要实现一个简化版的 React（或 Vue），你会如何设计？
2. 如何在 React 中实现一个可中断的渲染任务调度器？
3. 讲讲你在大型项目中做过的架构重构。
4. 你如何设计组件库？有哪些规范与自动化工具链？
5. 在 Flutter / React Native 跨端开发中，你遇到过的性能瓶颈及优化方案？

---

## 🧮 四、网络与安全

### ✅ 基础

1. TCP 三次握手和四次挥手过程？
2. HTTPS 的加密过程？
3. HTTP/1.1、HTTP/2、HTTP/3 的区别？
4. 常见的HTTP状态码有哪些？
5. Cookie、Session、Token、JWT 的区别？

### ⚙️ 进阶

1. 什么是CORS？如何安全地解决跨域？
2. XSS 和 CSRF 的攻击原理与防御方案？
3. 如何在前端保障数据安全？
4. 前端如何实现断点续传、秒传、并发上传？
5. WebSocket 和 SSE 的区别与使用场景？

### 🧠 深入

1. 你如何优化大文件上传过程中的传输性能？
2. 前端如何处理复杂权限控制？
3. 如何在前端层面实现加密存储与防篡改机制？
4. 你对 QUIC 协议的理解？
5. WebAssembly 在前端性能优化中的应用场景？

---

## 🧰 五、构建与工程化

### ✅ 基础

1. Webpack、Vite 的构建原理？
2. Tree-shaking 的原理？
3. Babel 的作用是什么？preset-env 是怎么工作的？
4. 如何处理 polyfill？
5. package-lock.json 的作用？

### ⚙️ 进阶

1. Rollup、ESBuild、Vite 的区别？
2. 如何提升构建速度？
3. CI/CD 在前端工程化中如何设计？
4. Monorepo 与 Multirepo 的取舍？
5. 如何搭建自己的组件库或npm包？

### 🧠 深入

1. 如何实现一个简化版的打包器？
2. 如何在大规模项目中优化依赖管理与构建速度？
3. 讲讲你设计或维护过的前端工程体系。
4. 如何做灰度发布与版本回滚？
5. 代码质量保障体系：Lint、Prettier、Test、Review 如何配合？

---

## 🧭 六、业务与架构设计

1. 当项目体量变大后，你如何设计前端架构？
2. 微前端的优缺点与使用场景？
3. 你如何在项目中做性能监控与异常监控？
4. 如何定位线上白屏或接口异常问题？
5. 如何设计一个高扩展性、低耦合的前端系统？

---

## 🔍 七、开放问题（软实力与思维）

1. 你如何衡量一次前端优化是否有效？
2. 描述一次你主导的技术决策过程。
3. 当设计方案和后端或产品冲突时，你会怎么处理？
4. 如果给你一个新团队，从零开始搭建项目，你会如何规划？
5. 你最近学习的技术是什么？为什么学它？

---
