## 自我介绍

## 项目介绍


## 🧩 一、JavaScript与TypeScript

### ✅ 基础

#### ✅ JS 的执行机制是怎样的？事件循环中有哪些队列？事件循环

JavaScript 是单线程的。事件循环是用来协调同步任务和异步任务的执行机制。
每次循环会先执行一个宏任务（例如 script、setTimeout），执行过程中产生的微任务（如 Promise.then）会在当前宏任务结束后立即执行。
当所有微任务清空后，浏览器可能进行渲染，然后进入下一轮循环。
这保证了 JS 在单线程下依然可以高效地处理异步逻辑。

事件循环中主要有两个队列：
1️⃣ 宏任务队列（Macro Task Queue）：包括 setTimeout、setInterval、setImmediate、I/O、script(整体代码) 等。
2️⃣ 微任务队列（Micro Task Queue）：包括 Promise.then、MutationObserver、queueMicrotask 等。



浏览器中则是 宏任务 → 微任务 → 渲染 → 下一轮。


#### ✅ 浏览器的事件循环和node的事件循环区别
浏览器与Node.js事件循环的核心区别在于架构与调度机制。

浏览器Event Loop：处理单个执行环境的异步。它分为宏任务队列（如 setTimeout）和微任务队列（如 Promise）。关键机制：每执行一个宏任务，就会清空整个微任务队列，随后可能进行页面渲染。

Node.js Event Loop：由libuv库实现，处理整个运行时的高并发I/O。它被分为六个循环阶段（如timers、poll、check）。关键机制：微任务（如 Promise）和更高优先级的 process.nextTick 在每个阶段结束后、下一个阶段开始前被清空。

Node.js 也有事件循环，但分为多个阶段（timers、poll、check等），微任务会在每个阶段后执行。
事件循环阶段（6 个主要阶段）

把阻塞的 I/O 操作交给系统或线程池，主线程通过事件循环不断处理回调。
1. timers：执行 setTimeout、setInterval 的回调。
2. pending callbacks：执行上一轮未处理的 I/O 回调。
3. idle / prepare：内部使用，Node 自身的准备阶段。
4. poll：轮询新的 I/O 事件，是事件循环的核心阶段：
    - 若有 I/O 回调，则执行它们；
    - 若无，则可能进入等待或跳到下一个阶段。
5. check：执行 setImmediate 的回调。
6. close callbacks：执行关闭事件的回调（如 socket.on('close')）。


#### ✅ `var`、`let`、`const` 的区别是什么？为什么存在暂时性死区？
var 是函数作用域，会变量提升，声明前访问值为 undefined；
let 和 const 是块级作用域，也会被提升，但在声明前处于“暂时性死区”，访问会报错；
const 还要求声明时必须赋初值，且不能重新赋值。

存在暂时性死区是为了避免变量提升导致的逻辑混乱，让变量在声明之前不能被访问，语义更清晰。

#### ✅ 调用栈、执行上下文
调用栈 是一个数据结构，用于追踪代码的执行位置。它遵循后进先出原则。当一个函数被调用时，其执行上下文会被压入栈顶；当函数执行完毕，上下文会从栈顶弹出，控制权交还给下一个上下文。

执行上下文 是JavaScript代码执行时的环境，包含三个核心部分：
1. 变量环境：存储 var 和函数声明。
2. 词法环境：存储 let 和 const 声明。
3. this绑定。

两者关系：调用栈是容器，执行上下文是内容。栈底的永远是全局执行上下文，栈顶的是当前正在执行的函数执行上下文。正是这种压栈和出栈的机制，驱动着程序的运行。


#### ✅ 作用域、作用域链
作用域 定义了变量和函数在代码中的可访问范围。它是在代码编写时（词法阶段）就确定的，也称为词法作用域。主要有三种：
作用域决定了变量的生命周期和可见性。
- 全局作用域
- 函数作用域
- 块级作用域（由 let/const 和 {} 创建）

作用域链 是当访问一个变量时，JavaScript引擎会从当前作用域开始查找，如果找不到，就逐级向外层（父级）作用域查找，直到全局作用域。这个查找过程所形成的链式结构就是作用域链。

核心：作用域是**规则**，决定了哪里能访问变量；作用域链是**查找机制**，决定了如何找到变量。闭包就是函数记住了并能访问其词法作用域，即使该函数在其作用域外执行。

#### ✅ 解释闭包。闭包可能导致哪些性能或内存问题？

闭包是指一个函数可以访问其外部函数作用域中的变量，即使外部函数已经执行结束。

闭包的本质是函数+其引用的外部变量环境。

性能/内存问题：
闭包会使外层函数的变量无法被垃圾回收，如果大量创建或长期持有闭包，可能造成内存泄漏。

优化建议：
在不再需要时手动释放引用，例如将闭包变量设为 null 或让引用脱离作用域。

节流防抖模块化私有变量

#### ✅ `this` 在不同调用场景下如何绑定？箭头函数为什么不能修改 `this`？
  * this的理解
    1. 全局执行上下文中的 this 是指向 window 对象的。严格模式是undefined
    2. 类中的this指向实例
    3. 函数中的this：箭头函数、普通函数
  * 改变this
    1. call，bind，apply
    2. 通过对象调用方法设置。使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的。
    3. 构造函数设置。new对象this指向新对象
    4. ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数。

####  ✅ 原型与原型链的工作原理是什么？
在 JavaScript 中，每个对象都有一个内部属性 [[Prototype]]（可通过 __proto__ 访问），它指向另一个对象，称为原型（prototype）。

对于函数来说，函数本身也有一个 prototype 属性，用来给通过 new 创建的实例对象设置它们的原型。

当我们访问一个对象的属性时：
1️⃣ JS 会先在对象自身查找；
2️⃣ 如果没有找到，就沿着 [[Prototype]] 向上查找；
3️⃣ 一直查到 Object.prototype，若仍未找到则返回 undefined。

这条从对象自身一路向上的查找链就叫做原型链（Prototype Chain）。



### ⚙️ 进阶

####  ✅ Promise 是如何实现的？`then` 链式调用是怎么保证顺序的？
Promise 是一种异步编程模型，本质是一个状态机，有三种状态：pending、fulfilled、rejected，状态一旦变化就不可逆。

内部实现是通过在构造函数中接收一个执行器函数 (resolve, reject)，执行时会：
1️⃣ 立即执行同步逻辑；
2️⃣ 把异步回调存入任务队列；
3️⃣ 调用 resolve 或 reject 后触发状态变化，并依次执行回调。

then 的链式调用依靠返回新的 Promise 实例实现：

每次调用 .then() 都会生成一个新的 Promise；

上一个 Promise 的结果会传递给下一个；

如果回调函数返回一个值，会用 resolve 包装；

如果返回的是 Promise，则会等待它的状态（即“扁平化”机制）。

顺序保证机制：
then 中注册的回调会被放入 微任务队列（Microtask Queue），
在当前宏任务执行完后按注册顺序执行，
所以 .then().then().then() 是严格按顺序依次执行的。

####  ✅ async/await 底层是如何实现的？与生成器函数（generator）有什么关系？
async/await 是对 Promise 和 Generator 的语法糖，本质上是通过自动执行 Generator 来实现同步风格的异步代码。

当你声明一个 async 函数时，它会默认返回一个 Promise；
函数内部的 await 会暂停执行，等待右侧表达式的 Promise resolve，然后恢复执行。

底层原理是：
1️⃣ async 函数在执行时，会像生成器一样被“分段执行”；
2️⃣ 每次遇到 await，JS 引擎会将后续代码封装成 Promise 回调（即微任务）；
3️⃣ 当 Promise resolve 后，恢复函数执行；
4️⃣ 如果抛出异常，则相当于 Promise reject。

####  ✅ 解释事件委托机制，它的性能优势体现在哪？

事件委托是指不直接给每个子元素绑定事件，而是把事件绑定到父元素上，通过事件冒泡来统一处理子元素的事件。

原理：
1️⃣ 当事件发生在子元素时，会向上传播到父元素（冒泡）；
2️⃣ 父元素在事件处理函数里，通过 event.target 判断实际触发的子元素；
3️⃣ 根据条件执行对应逻辑。

性能优势：
1️⃣ 减少内存占用：只绑定一个事件处理函数，而不是每个子元素都绑定。
2️⃣ 动态元素也可生效：新增的子元素无需再绑定事件，父元素的事件处理器自动生效。
3️⃣ 管理更方便：统一处理逻辑，减少重复代码。

####  ✅ Symbol、Proxy、Reflect 分别的应用场景是什么？

**Symbol**：唯一值，用于**避免属性名冲突**。主要场景：
*   为对象定义唯一的元属性（如 `Symbol.iterator` 使对象可迭代）。
*   定义对象内部的、不希望被外部常规代码访问的私有属性。

**Proxy**：对象代理，用于**拦截并自定义对象的基本操作**。主要场景：
*   实现响应式系统（Vue 3核心），拦截 `get` 和 `set` 以追踪依赖和触发更新。
*   实现高级功能，如数据验证、日志记录、自动默认值。

**Reflect**：反射API，提供**操作对象的默认行为**。主要场景：
*   与 `Proxy` 配对使用，在拦截器内部方便地调用对象的原始方法。
*   提供更函数化、更安全的方式来执行对象操作（如 `Reflect.deleteProperty(obj, key)` 替代 `delete obj[key]`）。

**核心关系**：`Proxy` 用于**拦截**行为，`Reflect` 用于**实现**默认行为，两者结合能优雅地控制对象。`Symbol` 则用于安全地扩展对象。


####  ✅ 深拷贝实现有哪些方式？其中的陷阱是什么？

1.  **`JSON.parse(JSON.stringify(obj))`**
    *   **原理**：利用JSON序列化与反序列化。
    *   **陷阱**：
        *   丢失 `Function`, `RegExp`, `Date`, `Map`, `Set`, `undefined`。
        *   忽略 `Symbol` 作为键的属性。
        *   无法处理循环引用，会直接报错。

2.  **递归手动实现**
    *   **原理**：遍历对象属性，递归拷贝原始值、数组和普通对象。
    *   **陷阱**：
        *   **循环引用**：对象间接或直接引用自身，导致递归栈溢出。解决方案：使用 `WeakMap` 存储已拷贝对象。
        *   **性能瓶颈**：深度嵌套对象耗时较长。
        *   **无法拷贝特殊对象**：如 `Date`, `RegExp`, `Function` 等，需要单独识别和处理。
        *   **忽略原型链**：拷贝后对象的原型指向 `Object.prototype`。

3.  **使用现成库**（如 Lodash `_.cloneDeep`）
    *   **原理**：成熟的实现，处理了上述所有边界情况。
    *   **陷阱**：增加项目体积，但通常是最可靠的选择。

**核心陷阱排序**：**循环引用** > **特殊对象类型丢失** > **函数丢失** > **性能问题**。一个健壮的深拷贝必须首先解决循环引用问题。

### 🧠 深入

####  ✅ JS 引擎如何进行内存管理与垃圾回收？

JS引擎的内存管理是自动的，基于**垃圾回收**机制，核心步骤如下：

1.  **内存分配**：当您创建变量、对象或函数时，引擎会自动为其分配内存。

2.  **垃圾回收**：定期找出不再使用的内存并将其释放。主流策略是 **标记-清除算法**：
    *   **标记阶段**：从**根对象**（全局变量、当前函数调用栈）出发，遍历所有能**被访问到的对象**，并标记为“可达”。
    *   **清除阶段**：将所有未被标记为“可达”的对象视为**垃圾**，回收其内存。

**关键补充与优化**：

*   **代际假说**：大多数对象存活时间很短。因此，V8等引擎将堆内存分为**新生代**（副垃圾回收器，频繁回收，使用Scavenge算法）和**老生代**（主垃圾回收器，较少回收，使用标记-清除/整理算法）。
*   **循环引用**：在标记-清除算法下，如果两个对象互相引用，但都无法从根对象访问到，它们仍会被正确回收。
*   **内存泄漏**：并非GC失效，而是由于**意外的全局变量**、**未被清除的闭包引用**或**遗忘的定时器/事件监听器**，导致本应回收的对象仍被标记为“可达”。


#### 解释一次 JS 的“编译执行”全过程，从解析到优化。

现代JS引擎（如V8）的执行是**即时编译**的混合模式，全过程如下：

1.  **解析**
    *   **词法分析**：将源代码字符串拆解成**词法单元**。
    *   **语法分析**：将词法单元流转换为**抽象语法树**。

2.  **编译与执行**
    *   **解释器**：将AST转换为**字节码**并**立即执行**。此举能快速启动。
    *   **编译器**：在解释器执行字节码的同时，**监控器** 会分析代码执行频率。**热点代码**（频繁执行的函数）会被发送给**即时编译器**，编译成高度优化的**机器码**后执行，极大提升性能。

3.  **优化与反优化**
    *   **优化**：JIT编译器会基于代码的运行状态做出激进优化（如内联缓存、类型推断）。
    *   **反优化**：如果优化前提被打破（如函数传入新类型），引擎会**丢弃优化后的机器码**，回退到解释器字节码执行，确保正确性。

**核心思想**：牺牲一部分编译时间来换取更快的执行速度，并通过监控和多层编译机制，在启动速度和峰值性能间取得最佳平衡。

---

## 🧱 二、浏览器与性能优化

### ✅ 基础

#### ✅ 从输入 URL 到页面渲染完成，发生了什么？
输入URL → (查找资源缓存) → DNS解析 → 建立TCP → 建立TLS → 发送HTTP请求 → 服务器响应 → 浏览器解析渲染 → 页面展示 → img等资源的加载、用户操作响应

浏览器的渲染流程有哪些关键阶段？（解析、构建DOM、CSSOM、合成层等）
渲染路径 构建 -> 样式计算 -> 布局 -> 绘制 -> 合成

#### ✅ 什么是重排（Reflow）与重绘（Repaint）？

**重排** 和 **重绘** 是浏览器渲染引擎更新页面的两个关键过程。

*   **重排**：当元素的**几何属性**（如宽、高、位置）发生改变，影响了文档的**布局**时，浏览器需要重新计算所有受影响元素的几何信息，并确定它们在页面中的新位置。这个过程也称为**布局**。

*   **重绘**：当元素的**外观属性**（如颜色、背景色、可见性）发生改变，但**不影响其布局**时，浏览器只需要将元素的新样式重新绘制到屏幕上。

**关键关系**：**重排必然会引起重绘**，但重绘不一定会引发重排。

**性能影响**：**重排的成本远高于重绘**，因为它涉及复杂的布局计算，可能引发整个渲染树的重新计算。频繁的重排是导致性能问题的主因。

优化原则：

避免频繁操作 DOM，批量修改

使用 class 切换而非逐个样式修改

使用 transform、opacity 做动画，避免触发 Reflow

#### 如何减少白屏时间？

减少白屏时间的关键在于**优化关键渲染路径**，核心目标是让浏览器**尽可能早地**开始第一次渲染。

1.  **减少资源阻塞**：
    *   **CSS**：使用 `media` 属性将非关键CSS标记为不阻塞渲染。将关键CSS内嵌在 `<head>` 中。
    *   **JS**：使用 `async` 或 `defer` 属性异步加载非关键JS，避免JS解析阻塞HTML解析和DOM构建。

2.  **加速首次内容渲染**：
    *   **服务端渲染**：在服务端生成初始HTML，用户直接看到内容，而非空白页面。
    *   **静态资源优化**：对资源进行压缩、使用CDN加速、配置HTTP/2甚至HTTP/3。

3.  **优化资源加载**：
    *   **资源预加载**：使用 `rel="preload"` 提前加载关键字体、CSS或JS。
    *   **缓存策略**：强缓存与协商缓存合理配置，减少重复请求。

4.  **前端架构优化**：
    *   **代码分割与懒加载**：利用打包工具将代码拆分成多个块，按需加载，减少初始JS体积。

**核心思路**：优先交付和呈现用户能看到的内容，延迟或异步处理非关键资源。

### ⚙️ 进阶

#### ✅ 浏览器缓存机制（强缓存 / 协商缓存）是如何工作的？

浏览器缓存机制分为两个阶段，按顺序进行：

##### 1. 强缓存
浏览器在请求资源时，**不会立即向服务器发送请求**，而是先检查本地缓存是否有效。

*   **判断依据**：检查 `Cache-Control`（优先级高，HTTP/1.1）和 `Expires`（HTTP/1.0）响应头。
    *   `Cache-Control: max-age=3600` 表示资源在内存缓存中有效3600秒。
    *   `Cache-Control: no-cache` 会**跳过强缓存**，直接进入协商缓存。
    *   `Cache-Control: no-store` 完全不使用任何缓存。
*   **结果**：如果缓存未过期，则**直接使用本地缓存**，HTTP状态码为 `200 (from memory/disk cache)`。

##### 2. 协商缓存
当强缓存失效后，浏览器会**向服务器发送请求**，由服务器判断资源是否变更。

*   **判断依据**：
    *   `Etag` / `If-None-Match`：文件的唯一标识符（哈希值）。服务器对比 `If-None-Match` 与当前资源的 `Etag`。
    *   `Last-Modified` / `If-Modified-Since`：文件的最后修改时间。服务器对比 `If-Modified-Since` 的时间。
*   **结果**：
    *   如果资源未变（`Etag` 匹配），服务器返回 **`304 Not Modified`**，浏览器继续使用本地缓存。
    *   如果资源已变，服务器返回 **`200 OK`** 和新的资源内容。

**工作流程**：强缓存 -> (失效) -> 协商缓存 -> (未变) 304 / (已变) 200。


#### ✅ 同源策略是什么？如何安全地实现跨域通信？

**同源策略**是浏览器的一个核心安全机制，它限制一个源的文档或脚本如何与另一个源的资源进行交互。"同源"指的是**协议、域名、端口**三者完全相同。此策略主要用于隔离潜在的恶意文档，防止数据被恶意窃取。

---

### ✅ 安全实现跨域通信的方案：

1.  **CORS**
    *   **原理**：由服务端在HTTP响应头中设置 `Access-Control-Allow-Origin` 等字段，明确告知浏览器允许哪些源进行跨域访问。这是**最主流、最安全**的方案。
    *   **场景**：适用于前后端分离的API调用。

2.  **JSONP**
    *   **原理**：利用 `<script>` 标签天然可跨域的特性，通过回调函数来获取数据。
    *   **场景**：仅支持GET请求，安全性较低，常用于旧项目或非敏感数据。

3.  **PostMessage**
    *   **原理**：允许来自不同源的窗口/iframe之间进行安全的双向通信。需要明确指定目标窗口的源。
    *   **场景**：窗口与内嵌iframe间的通信。

4.  **WebSocket**
    *   **原理**：WebSocket协议本身允许跨域连接。服务端通过 `Origin` 头来决定是否接受连接，实现访问控制。
    *   **场景**：需要全双工实时通信的应用。

5.  **反向代理**
    *   **原理**：在开发或部署时，通过代理服务器（如Nginx）将前端和后端API映射到同一个源下，从而绕过浏览器的同源限制。
    *   **场景**：开发环境解决跨域，生产环境部署时统一入口。

**总结**：对于现代Web应用，**CORS** 是解决跨域API请求的标准方案，而 **PostMessage** 和 **WebSocket** 则用于特定的跨窗口或实时通信场景。
#### ✅ Chrome 的多进程架构设计有哪些优点？

Chrome的多进程架构核心是**将浏览器不同功能模块隔离到独立进程中**，其主要优点体现在：

1.  **稳定性与容错性**
    *   **标签页隔离**：单个标签页（渲染进程）的崩溃不会影响浏览器主进程或其他标签页，只需重新加载该标签即可。

2.  **安全性与沙箱化**
    *   **沙箱模型**：渲染进程运行在严格的沙箱环境中，无权直接访问系统资源（如文件、网络），极大限制了恶意代码的危害。

3.  **性能与流畅度**
    *   **资源独占**：每个进程拥有独立的内存空间，避免了单进程内所有标签争抢资源，使得复杂网页不会拖慢整个浏览器。
    *   **响应迅速**：浏览器主进程（UI进程）与渲染进程分离，即使某个网页脚本执行缓慢或阻塞，浏览器界面本身（地址栏、按钮）仍能保持响应。

4.  **合理的资源管理**
    *   允许操作系统将不同进程调度到不同CPU核心上并行执行，更好地利用多核性能。关闭标签页时可以彻底释放其占用的所有资源。

**核心思想**：通过**牺牲一部分内存开销**，换来更高的**稳定性、安全性和响应能力**。

#### 如何分析与优化首屏性能？具体指标有哪些（如 LCP、FID、CLS）？

分析与优化首屏性能是一个系统性的过程，分为 **度量** 和 **优化** 两步。

---

##### 一、 核心性能指标

现代性能监控更关注**用户体验**，核心指标来源于 **Web Vitals**：

1.  **LCP**：最大内容绘制。测量**加载**体验。表示页面中最大可见元素（如图片、标题）变为可见的时间。应小于 **2.5秒**。
2.  **FID**：首次输入延迟。测量**交互**体验。表示用户第一次与页面交互（如点击）到浏览器实际响应的延迟。应小于 **100毫秒**。
3.  **CLS**：累积布局偏移。测量**视觉稳定性**。表示页面生命周期内发生的所有意外布局偏移的分数。应小于 **0.1**。

**传统指标**：`DOMContentLoaded`、`First Paint`、`First Contentful Paint`。

---

##### 二、 分析与度量方法

1.  **实验室工具**：在可控环境中模拟测试。
    *   **Lighthouse**：提供全面的性能评分和优化建议。
    *   **Chrome DevTools Performance面板**：深入分析运行时性能，定位瓶颈。

2.  **真实用户监控**：收集线上用户的真实数据。
    *   使用 **`web-vitals`** 库轻松测量核心指标并上报。
    *   利用 **Chrome User Experience Report** 查看大盘数据。

---

##### 三、 关键优化手段

1.  **优化LCP**：
    *   **优化关键资源**：对关键图片进行预加载 (`<link rel="preload">`)，使用现代图片格式。
    *   **服务端优化**：启用服务器端渲染或静态站点生成，减少TTFB。
    *   **消除渲染阻塞资源**：内联关键CSS，异步加载非关键JS。

2.  **优化FID**：
    *   **减少JS执行时间**：代码分割、懒加载、优化打包体积。
    *   **分解长任务**：将长时间运行的JS任务分解为小块。

3.  **优化CLS**：
    *   **为媒体元素设置尺寸**：为图片和视频始终指定 `width` 和 `height`。
    *   **避免动态插入内容**：或在插入内容前预留空间。
    *   **使用 `transform` 做动画**：避免动画影响布局。

**核心思路**：度量为先，针对瓶颈，优先处理影响用户体验最严重的环节。

#### 如何利用 Web Worker 提升性能？

### 🧠 深入

1. 解释浏览器的合成机制（Compositing），哪些CSS属性会触发新层？
2. 现代浏览器的渲染管线中，如何实现 GPU 加速？
3. Service Worker 在性能与离线缓存中的作用？
4. 如何调优一段耗时的渲染任务，避免阻塞主线程？
5. 讲讲你做过的性能优化案例，效果如何？数据如何量化？

---

## ⚛️ 三、框架与工程化（React / Vue / Flutter / RN）

### ✅ 基础

#### ✅ React 的虚拟 DOM 是什么？为什么要用它？

##### 虚拟DOM是什么？

虚拟DOM是一个**轻量的JavaScript对象**，它是真实DOM的抽象表示。React用它来描述我们希望页面的样子。

*   **结构**：本质上是一个嵌套的JS对象（React Element树），包含了标签名、属性、子元素等信息。
*   **创建**：在组件渲染时，`render` 方法会返回一个新的虚拟DOM树。

---

##### 为什么要用虚拟DOM？（核心价值）

它的首要目的**不是更快地更新DOM**，而是为了实现更**声明式**和**可预测**的编程模型，并在此基础上提供不错的性能。其价值体现在两个层面：

**1. 声明式与抽象层**
*   **解决了什么**：免去开发者手动进行繁琐、易错的DOM操作（如 `appendChild`, `removeChild`）。
*   **如何实现**：你只需要**声明**视图应该是什么状态，React负责通过虚拟DOM将状态映射到实际的DOM更新上。这极大地提升了开发效率和代码可维护性。

**2. 高效的协调算法**
*   **解决了什么**：在声明式编程下，任何状态变化都会触发整棵组件树的重新渲染，直接操作真实DOM代价高昂。
*   **如何实现**：
    *   **Diffing**：当状态变化，生成新的虚拟DOM树后，React会将新树与旧树进行**比较（Diff）**，精确找出发生变化的最小节点集合。
    *   **批量更新**：React会将计算出的所有DOM更新**批量处理**，在一次重排/重绘周期中完成，避免了不必要的布局计算。

**总结**：虚拟DOM的核心价值是提供了 **“声明式编程 + 高效的差异化更新”** 的组合。它通过 **JS运算（Diffing）** 的成本来换取**减少昂贵DOM操作**的成本，并在复杂的应用交互中保持性能的稳定和可预测。
#### ✅ Vue 的响应式原理（2.x vs 3.x）区别？

Vue 2.x 和 3.x 响应式原理的核心区别在于**数据拦截的实现方式**和**依赖收集的粒度**。

---

### Vue 2.x

*   **实现方式**：使用 `Object.defineProperty` 递归地劫持对象的**已有属性**的 `getter` 和 `setter`。
*   **依赖收集**：每个组件实例对应一个 **Watcher**。在 `getter` 中收集依赖（这个Watcher），在 `setter` 中通知依赖更新。
*   **已知限制**：
    1.  **无法检测属性的添加或删除**，必须使用 `Vue.set`/`Vue.delete` API。
    2.  **无法原生支持数组索引和长度修改**，需要重写数组的变异方法（如 `push`, `pop`）。
    3.  **递归初始化**：对深层对象递归劫持，性能有初始成本。

---

### Vue 3.x

*   **实现方式**：使用 `Proxy` 和 `Reflect` 来创建响应式对象。
*   **依赖收集**：引入了更细粒度的 **Effect Scope** 和 **Reactive Effect**。依赖追踪的目标不再是整个组件（Watcher），而是具体的响应式变量。
*   **核心优势**：
    1.  **全面拦截**：`Proxy` 可以拦截对象的所有操作，包括**属性增删**、**数组索引修改**、`in` 操作符等，无需特殊API。
    2.  **性能提升**：
        *   **惰性代理**：只有访问到某个嵌套属性时，才会递归将其转换为响应式，减少初始开销。
        *   **更优的依赖跟踪**：能精确知道是哪个属性被访问，从而在更新时触发更少的副作用。

---

Composition API 通过函数式的方式组织组件逻辑，让代码更清晰、复用更灵活

ref() 与 reactive()

ref()：创建单个响应式数据（包装基本类型或对象）。

reactive()：创建响应式对象（深层代理）。

**本质演进**：Vue 3 的响应式系统从“被动拦截”升级为“主动代理”，功能更强大，性能更优越，为 `Composition API` 奠定了坚实基础。
#### React Hooks 的使用规则和底层原理？

##### ✅ React Hooks 的使用规则

1.  **只在最顶层调用 Hook**：不能在循环、条件或嵌套函数中调用 Hook。
2.  **只在 React 函数中调用 Hook**：在 React 的函数组件或自定义 Hook 中调用。

---

##### 底层原理（基于 Fiber 架构）

React 通过在内部维护一个 **“记忆状态”链表** 来跟踪 Hooks。

*   **Fiber 节点**：每个组件对应一个 Fiber 节点，它存储了组件的状态、副作用等信息。
*   **Hooks 链表**：在组件首次渲染时，每当调用一个 Hook（如 `useState`, `useEffect`），React 就会将其按执行顺序添加到该组件 Fiber 节点的 **Hooks 链表** 中。
*   **顺序的重要性**：后续渲染时，React 会**严格依赖这个链表的顺序**来依次读取每个 Hook 对应的状态。如果顺序被打乱（如在条件语句中调用 Hook），React 就无法正确地将状态与 Hook 关联起来，导致 bug。

**以 `useState` 为例**：
*   首次渲染：调用 `useState(initialValue)`，React 会创建一个 Hook 对象（包含 `state` 和 `queue`），将其放入链表，并返回 `[state, setState]`。
*   后续渲染：再次调用 `useState`，React 不会使用初始值，而是顺着链表找到对应的 Hook 对象，返回当前最新的状态。

**`useEffect` 的原理**：
*   它的依赖项数组会被存储到 Hook 对象里。每次渲染后，React 会将新的依赖项与上一次的进行**浅比较**。如果不同，就将副作用函数标记并在合适的时机（after paint）执行。

**核心**：Hooks 的本质是**将组件的状态和副作用与一个顺序确定的链表节点绑定**。规则保证了这种绑定的稳定性。

#### ✅ 组件通信有哪些方式？

React 组件通信方式根据组件关系不同，主要有以下几种：

##### 1. 父子组件通信
*   **父 -> 子**：通过 **`props`** 传递数据和函数。
*   **子 -> 父**：父组件通过 `props` 传递一个**回调函数**给子组件，子组件调用该函数向父组件传递数据。

##### 2. 兄弟组件通信
*   **状态提升**：将共享状态提升至最近的公共父组件，由父组件通过 `props` 分发和管理。这是 React 最推荐的基本方式。

##### 3. 深层级/任意组件通信
当组件层级很深或无关时，上述方式会变得繁琐，此时有更优方案：

*   **Context API**：创建一个 Context，由顶层 `Provider` 提供数据，底层任何子组件通过 `useContext` Hook 消费数据。适用于**全局、不频繁更新**的数据（如主题、用户信息）。

*   **状态管理库**：如 **Redux, Zustand, MobX**。
    *   创建一个**全局 Store**，组件通过 `useSelector` 等 API 订阅所需数据。
    *   通过 `dispatch` 动作或直接调用方法来更新状态。
    *   适用于**复杂应用状态**或**高频更新**的场景。

##### 4. 其他方式
*   **事件总线**：一个全局事件系统（如 `EventEmitter`），组件可订阅和发布事件。但它在 React 中不被提倡，因为它破坏了数据流 predictability，且易导致内存泄漏。
*   **Ref 传递**：父组件通过 `ref` 获取子组件实例（仅适用于 Class 组件）或调用子组件的方法（使用 `useImperativeHandle` Hook）。

**总结**：优先考虑 `props` 和**状态提升**，复杂场景下使用 **Context** 或**状态管理库**。选择取决于数据流动的复杂度和更新频率。
#### 生命周期钩子分别在什么时候执行？

#### react错误边界
React 错误边界是一种捕获并处理其子组件树中 JavaScript 错误，防止整个应用崩溃的 React 组件。

通过定义 static getDerivedStateFromError() 和/或 componentDidCatch() 这两个生命周期方法，就成为了错误边界。

函数组件目前无法直接充当错误边界，需要依赖第三方库或将其改写为类组件。

##### 能捕获什么错误？

渲染期间的生命周期方法和构造函数中的错误。

整个子组件树 during render.

提升用户体验：避免因局部组件错误导致整个白屏，提供友好的降级界面。

增强应用健壮性：隔离错误，让应用的其余部分能继续正常工作。

辅助问题排查：在 componentDidCatch 中集成日志上报，能快速定位线上问题。

#### Typescript相关

### ⚙️ 进阶

#### ✅ React Hooks： 解释 useEffect 和 useLayoutEffect 的区别。

`useEffect` 和 `useLayoutEffect` 的唯一区别在于它们**执行的时机**。

*   **`useEffect`**：是 **异步** 的。它会在浏览器完成本次的**绘制与布局之后**、下一次绘制之前被触发。它**不会阻塞**浏览器的渲染更新。

*   **`useLayoutEffect`**：是 **同步** 的。它会在所有的DOM变更之后、但浏览器**进行绘制之前**同步执行。它会**阻塞**浏览器的绘制。

### 核心影响与使用场景

*   **`useEffect`**：适用于**绝大多数副作用**，如数据获取、设置订阅、手动更改非布局相关的DOM等。这是默认的选择。

*   **`useLayoutEffect`**：适用于需要**同步计算样式或布局**的场景。如果你需要在一个DOM元素被绘制到屏幕之前，根据其新的样式或尺寸进行额外的读取或修改（比如测量元素尺寸、然后设置一个tooltip的位置），就必须使用 `useLayoutEffect`，这样可以避免用户看到闪烁的中间状态。

**简单比喻**：`useEffect` 是“事后诸葛亮”，而 `useLayoutEffect` 是“防患于未然”。
#### 在 useEffect 中清理副作用的必要性是什么？

在 `useEffect` 中清理副作用是 **防止内存泄漏、保证应用稳定性和正确性** 的关键手段。主要有三个场景：

1.  **防止内存泄漏**：当组件卸载时，必须清理在 `useEffect` 中创建的、会持续存在的资源。否则，这些资源会一直占用内存。
    *   **场景**：定时器 (`setInterval`, `setTimeout`)、事件监听器 (`addEventListener`)、WebSocket 连接。
    *   **清理**：在清理函数中清除定时器、移除事件监听、关闭连接。

2.  **避免无效更新**：当依赖项变化导致 `useEffect` 重新执行时，需要先清理上一次副作用造成的影响。
    *   **场景**：一个根据 `props.id` 获取数据的组件。如果 `id` 变化，发起了新的数据请求，应该取消上一次未完成的请求，防止旧数据覆盖新数据。

3.  **维持数据一致性**：在异步操作中，如果组件已卸载，清理函数可以阻止对已卸载组件状态的更新。
    *   **场景**：一个异步数据获取操作。如果在响应返回前组件卸载了，清理函数可以设置一个标志位，阻止后续的 `setState` 操作，避免在未挂载的组件上更新状态而报错。

**核心思想**：每次渲染都是一个独立的“版本”，清理函数的作用就是**清除属于上一个“版本”的、已经过时的影响**，确保当前渲染的副作用是干净且有效的。
#### ✅ useMemo 和 useCallback 的使用场景和陷阱是什么？

`useMemo` 和 `useCallback` 都是用于性能优化的Hook，其核心都是**通过缓存来避免不必要的重复计算**。

##### 使用场景

*   **`useMemo`**：用于**缓存计算代价高昂的结果**。
    *   **场景**：对大型数据集进行筛选、排序、转换等复杂计算。避免每次渲染都重复执行。

*   **`useCallback`**：用于**缓存函数本身**。
    *   **场景**：当将函数作为props传递给被 `React.memo` 优化的子组件时，缓存函数可以避免子组件因父组件渲染而进行不必要的重渲染。

##### 共同陷阱

1.  **不必要的优化**：这是最大的陷阱。缓存本身需要内存和计算成本。如果计算不昂贵或函数不作为props传递，使用它们反而可能**降低性能**。应该先测量，再优化。

2.  **依赖项数组错误**：如果依赖项数组填写不完整，会使用过期的缓存值，导致难以追踪的bug。

3.  **语义混淆**：`useCallback(fn, deps)` 等价于 `useMemo(() => fn, deps)`。它缓存的是**函数引用**，并不会阻止函数内部的逻辑在每次调用时执行。

**最佳实践**：默认不要使用。只有在遇到明确的性能问题（如渲染卡顿、子组件频繁无意义重渲染）时，才在测量后有针对性地使用。




#### 什么是fiber
Fiber 是 React 16 引入的底层架构，用于 **增量渲染和调度 UI 更新**。

* 它将渲染任务拆成小块，可中断、恢复，避免复杂更新阻塞主线程。
* 支持优先级调度，高优先级任务（如用户输入）先执行，低优先级任务延后。
* 每个组件对应一个 Fiber 节点，记录状态、子节点、兄弟节点等，形成链表树结构，用于高效更新。

#### fiber
#### 具体做了什么事情
#### fiber具体场景的执行优先级

Fiber 架构中的优先级机制，其核心目标是**确保高优先级的用户交互（如输入、点击）能够及时响应**，而低优先级的任务（如数据获取、离线渲染）可以适当让步。

##### 具体场景与优先级对应

React 内部定义了不同优先级，以下是从高到低的具体场景：

1.  **同步优先级**
    *   **场景**：`flushSync` 中的更新、输入框的防抖更新。
    *   **行为**：立即执行，不可中断。类似于旧版栈调和，用于需要与浏览器状态严格同步的场景。

2.  **最高优先级**
    *   **场景**：离散的用户输入，如**点击、按键**。
    *   **行为**：需要立即反馈，中断任何正在进行中的低优先级渲染，以保持应用响应灵敏。

3.  **高优先级**
    *   **场景**：**连续**的用户交互，如**鼠标悬停、滚动**。
    *   **行为**：需要快速响应，但如果一个最高优先级的更新到来，它会被中断。

4.  **普通优先级**
    *   **场景**：**最常见的场景**，如正常的 `setState` 更新。
    *   **行为**：这是默认的更新优先级。会被更高优先级的更新中断。

5.  **低优先级**
    *   **场景**：**延迟非紧急的更新**，如切换到新的页面、加载更多数据。
    *   **行为**：会为更高优先级的任务让步，可能会被多次中断和重启。

6.  **离线优先级**
    *   **场景**：**在后台预渲染**当前不可见的内容（如离屏的Tab页）。
    *   **行为**：优先级最低，永远不会阻塞用户交互。

##### 工作机制

React 使用**优先级调度**模型。当一个高优先级任务到达时（如用户点击）：
*   **中断**：React 会中断当前正在进行的低优先级渲染。
*   **处理**：先完成高优先级任务的整个渲染和提交。
*   **恢复/重启**：然后，要么恢复之前中断的低优先级任务，要么直接丢弃并重新开始。

**总结**：Fiber 优先级的意义在于，让 React 能够像操作系统调度进程一样，**智能地分配计算资源**，始终保证用户的紧急操作得到第一时间处理，从而提升用户体验的流畅度。

#### 怎么进行任务终止的

关键实现原理
Fiber 节点的结构：每个 Fiber 节点都是一个工作单元，包含了组件的类型、状态、DOM 信息，以及关键的指针（child, sibling, return），使得遍历可以暂停和恢复。

workLoopConcurrent：React 的并发工作循环。它在处理每个 Fiber 节点后，会检查是否还有剩余时间（通过 shouldYield 函数）。如果没有时间，或有更高优先级的更新到达，React 就会将控制权交还浏览器，并记录下当前已完成和下一个待处理的 Fiber 节点。

双缓存 Fiber 树：React 同时维护两棵 Fiber 树：

Current Tree：当前屏幕上显示内容对应的树。

WorkInProgress Tree：正在内存中构建的树，用于下一次渲染。

一个低优先级的 WorkInProgress Tree 构建被中断时，React 会直接丢弃这整棵未完成的树。当再次处理该任务时，它会基于最新的 Current Tree 和最新的 state，重新开始构建一棵新的 WorkInProgress Tree。

总结：Fiber 通过将渲染分解为可度量的小单元、在单元之间检查中断需求、以及使用双缓存树来安全地丢弃旧工作，实现了任务的终止与重启，从而优先响应用户交互。

#### React Fiber 架构解决了什么问题？
React Fiber 架构主要解决了 **React 之前同步渲染带来的性能和响应性问题**。具体来说：

1. **阻塞主线程问题**

   * 以前 React 更新是同步的，遇到大规模或复杂组件树更新时，会导致页面卡顿，用户交互被阻塞。
   * Fiber 将渲染拆分成小任务，可以暂停和恢复，避免长时间占用主线程。

2. **缺乏优先级调度**

   * 以前所有更新一视同仁，无法区分重要性。
   * Fiber 支持不同优先级的更新，高优先级任务（如输入、动画）先执行，低优先级任务（如后台渲染）可以延后。

3. **无法增量渲染**

   * 旧版 React 需要一次性完成整个更新，导致大组件树更新时性能下降。
   * Fiber 支持增量渲染（分时间片完成），保证 UI 响应流畅。

一句话总结：

> Fiber 架构让 React 的界面更新 **可中断、可分片、按优先级调度**，解决了大规模更新卡顿和响应慢的问题。


#### 2. Vue 的 Diff 算法与 React 的有什么不同？

Vue 和 React 的 Diff 算法核心思想相似，都是通过**同层比较**来尽量减少 DOM 操作，但在具体策略和优化侧重点上有所不同。

##### 核心区别

1.  **比较策略的起点**
    *   **React**：采用 **“两端到中间”** 的对称比较。同时遍历新旧列表的头部和尾部，通过四种情况的对比（旧头=新头，旧尾=新尾，旧头=新尾，旧尾=新头）来寻找可复用的节点。
    *   **Vue**：采用 **“两端到中间”** 的对称比较，但在此基础上，Vue 2/3 都优先进行**静态分析**，跳过不会变化的节点（如模板中的静态节点），直接比较动态部分。

2.  **处理未知列表的最佳策略**
    *   **React**：在对称比较无法处理时，React 会遍历剩余的新节点，**根据 `key` 在一个旧的 Map 中查找可复用节点**。如果找到则移动，找不到则新建。这种方式在列表顺序剧烈变动时效率很高。
    *   **Vue 2**：在没有 `key` 或情况复杂时，采用一种**更“贪心”的策略**：它会尝试就地复用相同类型的元素，并通过移动节点来匹配新列表的顺序。这可能导致更多的 DOM 移动，但在没有 `key` 的简单场景下表现尚可。
    *   **Vue 3**：在 Vue 2 的基础上，借鉴了类似 React 的 **“Map + 最长递增子序列”** 的算法。它会先建立一个基于 `key` 的旧节点 Map，然后找出**不需要移动的最长递增子序列**，只移动那些不在这个序列中的节点。这**最大限度地减少了节点的移动次数**。

##### 总结对比

| 特性 | React | Vue 2 | Vue 3 |
| :--- | :--- | :--- | :--- |
| **核心比较** | 两端到中间对称比较 | 两端到中间对称比较 | 两端到中间对称比较 |
| **静态优化** | 无（全部参与Diff） | **有**，跳过静态节点 | **有**，提升静态节点 |
| **`key`的作用** | **关键**，用于构建Map快速查找 | 重要，帮助识别节点 | **关键**，用于构建Map和LIS算法 |
| **节点移动** | 基于Map查找结果移动 | 贪心匹配，可能移动较多 | **基于最长递增子序列，移动最少** |

**结论**：Vue 通过**编译时优化**（静态提升）和**运行时算法**（最长递增子序列）的结合，在**更新稳定列表**时通常能比 React 产生更少的 DOM 操作。而 React 的算法在**处理顺序剧烈变化的列表**时非常稳健。两者都在各自的设计哲学下达到了极高的性能水平。

#### 3. 在复杂应用中，状态管理如何设计？Redux / MobX / Pinia / Recoil 对比？

Redux：严格不可变状态、适合大型复杂应用；
MobX：响应式自动追踪，适合中大型应用；
Pinia：Vue 官方推荐，响应式、易用；
Zustand：React hook 风格轻量状态管理，灵活简洁。

#### 对比Redux, MobX, Zustand或Context API的优缺点和适用场景。在什么情况下你会选择引入一个状态管理库？


#### 4. 如何优化 React 组件的重渲染？
除了 key，还有哪些提升渲染性能的手段？

优化 React 重渲染的核心思路是：**避免不必要的渲染，并对必要的渲染进行优化**。以下是具体策略，从易到难：

##### 1. 优化 State 与 Props

*   **保持 State 局部化**：不要将状态过度提升到高层组件，应放在真正需要它的组件内。
*   **保证 Props 引用稳定**：
    *   对于对象、数组或函数，如果它们不需要变化，就移到组件外定义；如果需要变化，使用 `useMemo` 和 `useCallback` 进行缓存，避免每次渲染都创建新的引用。

##### 2. 使用性能优化 API

*   **`React.memo`**：用于函数组件，对 props 进行浅比较，如果 props 没变，则跳过重渲染。适用于渲染成本较高、props 变化不频繁的纯展示组件。
*   **`useMemo` / `useCallback`**：作为 props 传递给被 `React.memo` 优化的子组件时，用于缓存值和函数，防止因父组件渲染导致子组件不必要的重渲染。

##### 3. 优化渲染结构与模式

*   **降低渲染粒度**：将状态下放至更小的子组件。一个大组件状态的更新会导致整棵树渲染，而小组件状态的更新只影响自身。
*   **使用 Children Props**：如果父组件渲染了子组件，但重渲染是由父组件的状态变化引起的，而子组件的 props 没变，可以将子组件作为 `children` 传递。这样父组件状态变化时，由于 `children` prop 的引用是稳定的，子组件不会重渲染。

##### 4. 关键工具与排查

*   **使用 React DevTools Profiler**：这是最重要的工具。通过它记录并分析渲染过程，精准定位是哪个组件的重渲染导致了性能瓶颈，而不是盲目优化。
*   **遵循不可变更新**：在更新状态时，务必使用不可变数据，否则浅比较会失效，导致优化 API（如 `React.memo`）失去作用。

**总结**：我的优化流程是：**1) 用 Profiler 定位问题 -> 2) 优先通过状态结构拆分降低渲染范围 -> 3) 对必要的跨组件传递的 props 使用 `useMemo`/`useCallback` -> 4) 最后对子组件使用 `React.memo`**。避免过早和过度优化。

#### 5. SSR（服务端渲染）与 CSR、Hydration 的区别与实现思路？

### 🧠 深入

1. 如果要实现一个简化版的 React（或 Vue），你会如何设计？
2. 如何在 React 中实现一个可中断的渲染任务调度器？
3. 讲讲你在大型项目中做过的架构重构。
4. 你如何设计组件库？有哪些规范与自动化工具链？
5. 在 Flutter / React Native 跨端开发中，你遇到过的性能瓶颈及优化方案？

---

## 🧮 四、网络与安全

### ✅ 基础
#### TCP 三次握手和四次挥手过程？

#### HTTPS 的加密过程？
#### HTTP/1.1、HTTP/2、HTTP/3 的区别？
#### HTTP/2的多路复用是如何解决队头阻塞问题的？
#### 常见的HTTP状态码有哪些？
#### Cookie、Session、Token、JWT 的区别？
#### https
1. CA证书是从哪里获取的
2. 怎么保证CA的有效性


建立流程TLS1.2
```
客户端（浏览器）                      服务器
     | -------- ClientHello --------> |   ① 提出加密支持
     | <-------- ServerHello -------- |   ② 确定加密方案
     | <---- Certificate + Key -----> |   ③ 服务器证书、公钥
     | -------- ClientKeyExchange --> |   ④ 客户端生成密钥
     | -------- ChangeCipherSpec ---->|   ⑤ 通知切换到加密模式
     | <------- ChangeCipherSpec -----|   ⑥ 服务端也切换
     | <------- Finished -------------|   ⑦ 握手完成
     | -------- Finished ------------>|   ⑧ 双方确认
（之后使用对称密钥加密传输 HTTP 数据）

```
👉 TLS 1.3 把 ServerHello 后的所有内容（包括证书）都放在加密通道里传输，安全性更强。
👉 同时支持 0-RTT 模式：如果是重连，可直接复用上次的会话密钥，几乎无延迟。


#### websocket
1. 数据传输方式
2. 状态码
3. 怎么实现重连

### ⚙️ 进阶

1. 什么是CORS？如何安全地解决跨域？
2. XSS 和 CSRF 的攻击原理与防御方案？
3. 如何在前端保障数据安全？
4. 前端如何实现断点续传、秒传、并发上传？
5. WebSocket 和 SSE 的区别与使用场景？

### 🧠 深入

1. 你如何优化大文件上传过程中的传输性能？
2. 前端如何处理复杂权限控制？
3. 如何在前端层面实现加密存储与防篡改机制？
4. 你对 QUIC 协议的理解？
5. WebAssembly 在前端性能优化中的应用场景？

---

## 🧰 五、构建与工程化

### ✅ 基础

1. Webpack、Vite 的构建原理？
2. Tree-shaking 的原理？
3. Babel 的作用是什么？preset-env 是怎么工作的？
4. 如何处理 polyfill？
5. package-lock.json 的作用？

### ⚙️ 进阶

1. Rollup、ESBuild、Vite 的区别？
2. 如何提升构建速度？
3. CI/CD 在前端工程化中如何设计？
4. Monorepo 与 Multirepo 的取舍？
5. 如何搭建自己的组件库或npm包？

### 🧠 深入

1. 如何实现一个简化版的打包器？
2. 如何在大规模项目中优化依赖管理与构建速度？
3. 讲讲你设计或维护过的前端工程体系。
#### 如何做灰度发布与版本回滚？

灰度发布与版本回滚是保障线上服务稳定性的核心运维手段。

---

##### 灰度发布

灰度发布的核心是**将新版本服务逐步、可控地暴露给一小部分用户，验证通过后再全量**。

**常用方案：**

1.  **基于流量比例**：
    *   **做法**：在网关或负载均衡器上配置路由规则，将一定比例（如5%）的用户流量导向新版本服务。
    *   **工具**：Nginx, Kubernetes Ingress, Service Mesh (Istio)。

2.  **基于用户特征**：
    *   **做法**：根据用户ID、设备类型、地理位置、标签等特征，将特定用户群体导向新版本。
    *   **场景**：优先让公司内部员工、测试用户或友好用户使用新版本。

3.  **基于功能开关**：
    *   **做法**：在代码中预置开关，通过配置中心动态控制新功能对特定用户群体开放或关闭，无需重新部署服务。
    *   **优势**：回滚速度极快，只需关闭开关。

**实施流程：**
1.  先进行**内部测试**。
2.  然后开放给 **1% 的真实用户**。
3.  逐步扩大范围至 **5% -> 20% -> 50%**。
4.  期间密切监控 **业务指标**（如转化率、订单量）和 **系统指标**（如延迟、错误率）。
5.  确认无误后，**100%全量发布**。

---

##### 版本回滚

当灰度期间发现新版本有严重问题时，必须能**快速、平滑地回滚到上一个稳定版本**。

**核心方案：**

1.  **基础设施回滚（推荐）**：
    *   **蓝绿部署**：线上同时运行着当前的“绿”环境和新版本的“蓝”环境。通过切换负载均衡器的路由，将所有流量从有问题的“蓝”环境瞬间切回稳定的“绿”环境。回滚速度极快（秒级），几乎零延迟。
    *   **滚动回滚**：在Kubernetes等容器平台上，直接更新Deployment的镜像版本为上一个稳定版，系统会自动逐步替换有问题的Pod。

2.  **代码/构建回滚**：
    *   **做法**：重新构建并部署上一个已知稳定的版本标签（Git Tag）。
    *   **缺点**：速度较慢，需要经过完整的构建和部署流程，服务中断时间较长。

**关键原则：**
*   **可观测性**：没有完善的监控（日志、指标、链路追踪），就无法及时发现问题，更谈不上回滚。
*   **自动化**：回滚流程应尽可能自动化，避免在紧急情况下因人工操作失误而扩大故障。
*   **数据兼容性**：回滚时必须考虑数据库 schema 和数据的**向后兼容性**，确保旧版本服务能正确处理新版本写入的数据。

5. 代码质量保障体系：Lint、Prettier、Test、Review 如何配合？

---

## 🧭 六、业务与架构设计

1. 当项目体量变大后，你如何设计前端架构？
2. 微前端的优缺点与使用场景？
3. 你如何在项目中做性能监控与异常监控？
4. 如何定位线上白屏或接口异常问题？
5. 如何设计一个高扩展性、低耦合的前端系统？

系统设计
组件设计
设计一个权限管理
状态管理
---

## 🔍 七、开放问题（软实力与思维）

1. 你如何衡量一次前端优化是否有效？
2. 描述一次你主导的技术决策过程。
3. 当设计方案和后端或产品冲突时，你会怎么处理？
4. 如果给你一个新团队，从零开始搭建项目，你会如何规划？
5. 你最近学习的技术是什么？为什么学它？

---
#### 如何与后端工程师联调
1. 联调前：定义契约，准备数据（接口契约、mock数据、测试用例）
2. 联调中：高效协作，定位问题（使用postman等工具）
3. 联调后：自动化与沉淀

#### 如何与设计师协作，保证效果与设计稿一致
1. 开发前：充分沟通，明确细节
2. 开发中：使用工具，精准还原
3. 开发后：共同走查，持续迭代

#### 线上出现了一个偶发bug如何定位和解决
1. 应急：
评估影响、采取措施（关闭入口，回滚）
2. 定位
收集现场信息、定位原因、修复与复盘

#### 你和同事的技术方案有分歧，会怎么处理
处理原则是 “对事不对人，以达成技术共识和项目成功为目标”
首先，倾听与理解：
然后，客观分析与数据驱动：将两个方案放在一起，基于客观标准进行对比。
寻求共同点与融合方案：
引入第三方视角：
尊重最终决策并坚决执行：


#### 职业规划
短期内深入理解新公司的业务模式、技术栈和团队协作流程，快速上手。在负责的领域内，承担复杂模块的设计与开发，确保高质量交付。

长期在团队或业务线中，成为该业务领域的权威。通过技术创新来驱动业务增长、提升用户体验或创造新的商业价值。根据公司需要和个人发展最大化我个人和团队对公司的价值。

#### 你为什么想看新的机会？你对下一份工作最大的期望是什么？
我过去的经验集中在互联网应用方面，对IoT相关接触较少，看到这个岗位后想尝试下有挑战性和发展前景的业务方向。

我追求一个能让我长期投入、共同成长的事业平台。让我的经验、能力和态度能与平台相互成就。

#### 学习什么新技术，有什么心得

前端如何与硬件设备通信

IoT物联网项目相关

### 函数柯里化
柯里化（Currying）：
是把接受多个参数的函数，转换成一系列只接收一个参数的函数的过程。

## 前端优化

打包构建优化：核心是减小体积和提升速度，主要通过 Tree Shaking、代码分割、缓存等手段。

加载性能优化：关注用户从输入 URL 到看到内容的速度，涉及资源预加载、懒加载和缓存策略。

运行时性能优化：关注页面运行时的流畅度，包括 JS 执行效率、渲染性能和内存管理。

框架级优化：针对 React/Vue 等框架，使用其提供的 memo、useCallback 等 API 避免不必要的渲染。

网络与资源优化：聚焦于图片、请求和传输协议，比如使用 WebP 格式和 HTTP/2。

用户体验优化：提升用户感知，例如使用骨架屏、优化核心 Web 指标（LCP, FID, CLS）。

开发与工程化优化：保障长期可维护性，通过自动化工具、代码规范和监控体系来实现。


## 断点续传
1. 文件怎么分片
2. 具体怎么传
3. indexDB存储上限
IndexedDB 的存储上限不是固定值，而是动态配额。
一般来说：

桌面 Chrome 等 Chromium 浏览器：单源最多可用几 GB（约占磁盘空间 1%～10%）；

Safari / iOS 环境更严格（默认约 50MB～500MB）；

超出时会触发 QuotaExceededError；

可用 navigator.storage.estimate() 查询配额，并通过 navigator.storage.persist() 申请持久存储。


### 虚拟滚动列表和虚拟dom有什么相似与区别
### 文件导出重难点是什么
### 写一个多线程执行任务的最短时间，比如有一个tasks数组，记录了每个任务的执行时间，有一个数n是当前有n个执行器，分别可以执行tasks里面的任务，怎么分配执行时间最短


---
## 项目经验与解决问题能力
最有挑战的项目： 请详细介绍一个你主导或深度参与的最有挑战性的前端项目。

追问： 技术选型的依据是什么？遇到了哪些重大技术难题？你是如何分析和解决的？项目的最终成果如何（最好有数据支撑）？

技术债务与重构： 请分享一个你处理技术债务或重构大型模块的经历。你是如何评估风险、制定方案并平稳落地的？

线上故障： 描述一个你遇到的线上故障（P0/P1级别），你是如何应急、定位根因并恢复的？事后总结了什么经验，如何避免类似问题再次发生？

跨团队协作： 在前端与后端、客户端、产品、测试等多方协作中，你遇到过什么沟通或协作上的挑战？是如何解决的？


## 软技能与职业发展

团队角色： 在过去的团队中，你通常扮演什么角色？（技术核心、项目推动者、导师等）

指导他人： 你有指导初级工程师或进行技术分享的经验吗？请举例说明。

技术成长： 你是如何保持技术敏感度和持续学习的？最近在研究什么新技术或新方向？

项目管理： 你是如何评估开发工作量、管理项目风险并保证按时交付的？

求职动机： 你为什么想看新的机会？你对下一份工作最大的期望是什么？（技术挑战、团队、业务方向等）

https://www.yuque.com/yuqueyonghua2m9wj/web_food/ftkiwu